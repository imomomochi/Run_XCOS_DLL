/*
**    SCILAB Computational function
**    Generated by Code_Generation toolbox of Xcos with scilab-6.1.0
**    Date : 10-6æœˆ-2021
*/

/* ---- Headers ---- */
#include <stdio.h>
#include <stdlib.h>
#include <memory.h>
#include <string.h>
#include "machine.h" 
#include "scicos.h" 
#include "scicos_malloc.h" 
#include "scicos_free.h" 
#ifndef max
#define max(a,b) ((a) >= (b) ? (a) : (b))
#endif
#ifndef min
#define min(a,b) ((a) <= (b) ? (a) : (b))
#endif

/* prototype of 'plusblk' (type 2) */
void plusblk(int *, int *, double *, double *, double *, int *, double *, \
             int *, double *, int *, double *, int *, int *, int *, \
             double **, int *, int *, double **,int *, int *);

/* prototype of 'dollar' (type 0) */
void C2F(dollar)(int *, int *, double *, double *, double *, int *, double *, \
                 int *, double *, int *, double *, int *,int *, int *, \
                 double *, int *, double *, int *);

/* prototype of 'cstblk' (type 1) */
void C2F(cstblk)(int *, int *, double *, double *, double *, int *, double *, \
                 int *, double *, int *, double *, int *,int *, int *, \
                 double *, int * );

/* prototype of 'dollar4' (type 4) */
void dollar4(scicos_block *, int );

/* prototype of 'gain' (type 0) */
void C2F(gain)(int *, int *, double *, double *, double *, int *, double *, \
               int *, double *, int *, double *, int *,int *, int *, \
               double *, int *, double *, int *);

/* Table of constant values */
static int nrd_0 = 0;
static int nrd_1 = 1;
static int nrd_2 = 2;
static int nrd_10 = 10;
static int nrd_11 = 11;
static int nrd_81 = 81;
static int nrd_82 = 82;
static int nrd_84 = 84;
static int nrd_811 = 811;
static int nrd_812 = 812;
static int nrd_814 = 814;

/* Some general static variables */
static double zero=0;
static double w[1];
static int aaa=0, bbb=0;

/*---------------------------------------- Block Computational function */ 
int  TestBlock(scicos_block *block, int flag)
{
  /* declaration of local variables for that block struct */
  double* z      = block->z;
  void **ozptr   = block->ozptr;
  void **oparptr = block->oparptr;
  int nopar      = block->nopar;
  double* x      = block->x;
  double* xd     = block->xd;
  double* res    = block->res;
  void** u       = block->inptr;
  void** y       = block->outptr;
  int nevprt     = block->nevprt;
  double* rpar   = block->rpar;
  int nrpar      = block->nrpar;
  int* ipar      = block->ipar;
  int nipar      = block->nipar;
  double* g      = block->g;
  int* mode      = block->mode;
  void **work    = block->work;

  double t     = get_scicos_time();
  int    phase = get_phase_simulation();

  int kf = 0;
  int i = 0;
  int* reentryflag = NULL;

  double *args[100];
  int local_flag;
  int nport;
  void **TestBlock_block_outtbptr;
  scicos_block *block_TestBlock;

  /*  work of blocks are catenated at the end of z */
  work = (void **)(z+2);

  /*  TestBlock_block_outtbptr is catenated at the end of oz */
  TestBlock_block_outtbptr = (void **)(ozptr+0);

  /* struct of all blocks are stored in work of that block struct */
  block_TestBlock=(scicos_block*) *block->work;

  /* Copy inputs in the block outtb */
  memcpy(*(TestBlock_block_outtbptr+7),*(u+0),1*sizeof(double));

  if (flag != 4 && flag != 6 && flag != 5){
    reentryflag=(int*) ((scicos_block *)(*block->work)+12);
    if (*reentryflag==0){
      *reentryflag=1;

      /* set blk struc. of 'capteur1' (type 0 - blk nb 1 - uid ) */
      block_TestBlock[0].outptr[0] = TestBlock_block_outtbptr[7];
      block_TestBlock[0].z         = &(z[0]);
      block_TestBlock[0].x         = &(zero);
      block_TestBlock[0].xd        = w;
      block_TestBlock[0].g         = &(zero);
      block_TestBlock[0].work      = (void **)(((double *)work)+0);

      /* set blk struc. of 'actionneur1' (type 0 - blk nb 2 - uid ) */
      block_TestBlock[1].inptr[0]  = TestBlock_block_outtbptr[3];
      block_TestBlock[1].z         = &(z[0]);
      block_TestBlock[1].x         = &(zero);
      block_TestBlock[1].xd        = w;
      block_TestBlock[1].g         = &(zero);
      block_TestBlock[1].work      = (void **)(((double *)work)+1);

      /* set blk struc. of 'plusblk' (type 2 - blk nb 3 - uid ) */
      block_TestBlock[2].inptr[0]  = TestBlock_block_outtbptr[7];
      block_TestBlock[2].inptr[1]  = TestBlock_block_outtbptr[8];
      block_TestBlock[2].outptr[0] = TestBlock_block_outtbptr[3];
      block_TestBlock[2].z         = &(z[0]);
      block_TestBlock[2].x         = &(zero);
      block_TestBlock[2].xd        = w;
      block_TestBlock[2].g         = &(zero);
      block_TestBlock[2].work      = (void **)(((double *)work)+2);

      /* set blk struc. of 'dollar' (type 0 - blk nb 4 - uid ) */
      block_TestBlock[3].inptr[0]  = TestBlock_block_outtbptr[3];
      block_TestBlock[3].outptr[0] = TestBlock_block_outtbptr[8];
      block_TestBlock[3].z         = &(z[0]);
      block_TestBlock[3].x         = &(zero);
      block_TestBlock[3].xd        = w;
      block_TestBlock[3].g         = &(zero);
      block_TestBlock[3].work      = (void **)(((double *)work)+3);

      /* set blk struc. of 'actionneur2' (type 0 - blk nb 5 - uid ) */
      block_TestBlock[4].inptr[0]  = TestBlock_block_outtbptr[1];
      block_TestBlock[4].z         = &(z[1]);
      block_TestBlock[4].x         = &(zero);
      block_TestBlock[4].xd        = w;
      block_TestBlock[4].g         = &(zero);
      block_TestBlock[4].work      = (void **)(((double *)work)+4);

      /* set blk struc. of 'cstblk' (type 1 - blk nb 6 - uid ) */
      block_TestBlock[5].outptr[0] = TestBlock_block_outtbptr[2];
      block_TestBlock[5].z         = &(z[1]);
      block_TestBlock[5].x         = &(zero);
      block_TestBlock[5].xd        = w;
      block_TestBlock[5].g         = &(zero);
      block_TestBlock[5].rpar      = &(rpar[0]);
      block_TestBlock[5].work      = (void **)(((double *)work)+5);

      /* set blk struc. of 'plusblk' (type 2 - blk nb 7 - uid ) */
      block_TestBlock[6].inptr[0]  = TestBlock_block_outtbptr[2];
      block_TestBlock[6].inptr[1]  = TestBlock_block_outtbptr[4];
      block_TestBlock[6].outptr[0] = TestBlock_block_outtbptr[5];
      block_TestBlock[6].z         = &(z[1]);
      block_TestBlock[6].x         = &(zero);
      block_TestBlock[6].xd        = w;
      block_TestBlock[6].g         = &(zero);
      block_TestBlock[6].work      = (void **)(((double *)work)+6);

      /* set blk struc. of 'plusblk' (type 2 - blk nb 8 - uid ) */
      block_TestBlock[7].inptr[0]  = TestBlock_block_outtbptr[0];
      block_TestBlock[7].inptr[1]  = TestBlock_block_outtbptr[6];
      block_TestBlock[7].outptr[0] = TestBlock_block_outtbptr[1];
      block_TestBlock[7].z         = &(z[1]);
      block_TestBlock[7].x         = &(zero);
      block_TestBlock[7].xd        = w;
      block_TestBlock[7].g         = &(zero);
      block_TestBlock[7].work      = (void **)(((double *)work)+7);

      /* set blk struc. of 'dollar4' (type 4 - blk nb 9 - uid ) */
      block_TestBlock[8].inptr[0]  = TestBlock_block_outtbptr[1];
      block_TestBlock[8].outptr[0] = TestBlock_block_outtbptr[0];
      block_TestBlock[8].z         = &(z[1]);
      block_TestBlock[8].x         = &(zero);
      block_TestBlock[8].xd        = w;
      block_TestBlock[8].g         = &(zero);
      block_TestBlock[8].work      = (void **)(((double *)work)+8);

      /* set blk struc. of 'gain' (type 0 - blk nb 10 - uid ) */
      block_TestBlock[9].inptr[0]  = TestBlock_block_outtbptr[0];
      block_TestBlock[9].outptr[0] = TestBlock_block_outtbptr[4];
      block_TestBlock[9].z         = &(z[2]);
      block_TestBlock[9].x         = &(zero);
      block_TestBlock[9].xd        = w;
      block_TestBlock[9].g         = &(zero);
      block_TestBlock[9].rpar      = &(rpar[1]);
      block_TestBlock[9].work      = (void **)(((double *)work)+9);

      /* set blk struc. of 'gain' (type 0 - blk nb 11 - uid ) */
      block_TestBlock[10].inptr[0]  = TestBlock_block_outtbptr[5];
      block_TestBlock[10].outptr[0] = TestBlock_block_outtbptr[6];
      block_TestBlock[10].z         = &(z[2]);
      block_TestBlock[10].x         = &(zero);
      block_TestBlock[10].xd        = w;
      block_TestBlock[10].g         = &(zero);
      block_TestBlock[10].rpar      = &(rpar[2]);
      block_TestBlock[10].work      = (void **)(((double *)work)+10);

      /* set blk struc. of 'bidon' (type 1 - blk nb 12 - uid ) */
      block_TestBlock[11].z         = &(z[2]);
      block_TestBlock[11].x         = &(zero);
      block_TestBlock[11].xd        = w;
      block_TestBlock[11].g         = &(zero);
      block_TestBlock[11].work      = (void **)(((double *)work)+11);
    }
  }

  if (flag == 1) { /* Output computation */
    switch (nevprt) {
      case 1 : /* Blocks activated on the event number 1 */
        /* Call of 'dollar' (type 0 - blk nb 4 - uid ) */
        block_TestBlock[3].nevprt = 1;
        local_flag = 1;
        args[0]=(double *)TestBlock_block_outtbptr[3];
        args[1]=(double *)TestBlock_block_outtbptr[8];
        C2F(dollar)(&local_flag,&block_TestBlock[3].nevprt,&t,block_TestBlock[3].xd, \
                    block_TestBlock[3].x,&block_TestBlock[3].nx, \
                    block_TestBlock[3].z,&block_TestBlock[3].nz,block_TestBlock[3].evout, \
                    &block_TestBlock[3].nevout,block_TestBlock[3].rpar,&block_TestBlock[3].nrpar, \
                    block_TestBlock[3].ipar,&block_TestBlock[3].nipar, \
                    (double *)args[0],&nrd_1,(double *)args[1],&nrd_1);
        if(local_flag < 0) return(5 - local_flag);
    
        /* Call of 'plusblk' (type 2 - blk nb 3 - uid ) */
        block_TestBlock[2].nevprt = 3;
        local_flag = 1;
        plusblk(&local_flag,&block_TestBlock[2].nevprt,&t,block_TestBlock[2].xd, \
                 block_TestBlock[2].x,&block_TestBlock[2].nx, \
                 block_TestBlock[2].z,&block_TestBlock[2].nz,block_TestBlock[2].evout, \
                 &block_TestBlock[2].nevout,block_TestBlock[2].rpar,&block_TestBlock[2].nrpar, \
                 block_TestBlock[2].ipar,&block_TestBlock[2].nipar, \
                 (double **)block_TestBlock[2].inptr,block_TestBlock[2].insz,&block_TestBlock[2].nin, \
                 (double **)block_TestBlock[2].outptr,block_TestBlock[2].outsz, &block_TestBlock[2].nout);
        if(local_flag < 0) return(5 - local_flag);
    
      break;

    }
  }
  else if (flag == 2) { /* Discrete state computation */
    switch (nevprt) {
      case 1 : /* Blocks activated on the event number 1 */
        /* Call of 'dollar' (type 0 - blk nb 4 - uid ) */
        block_TestBlock[3].nevprt = 1;
        local_flag = 2;
        args[0]=(double *)TestBlock_block_outtbptr[3];
        args[1]=(double *)TestBlock_block_outtbptr[8];
        C2F(dollar)(&local_flag,&block_TestBlock[3].nevprt,&t,block_TestBlock[3].xd, \
                    block_TestBlock[3].x,&block_TestBlock[3].nx, \
                    block_TestBlock[3].z,&block_TestBlock[3].nz,block_TestBlock[3].evout, \
                    &block_TestBlock[3].nevout,block_TestBlock[3].rpar,&block_TestBlock[3].nrpar, \
                    block_TestBlock[3].ipar,&block_TestBlock[3].nipar, \
                    (double *)args[0],&nrd_1,(double *)args[1],&nrd_1);
        if(local_flag < 0) return(5 - local_flag);
    
      break;

    }
  }
  else if (flag == 4) { /* Initialization */
    if ((*block->work=scicos_malloc(sizeof(scicos_block)*12+sizeof(int)))== NULL) return 0;
    reentryflag=(int*) ((scicos_block *)(*block->work)+12);
    *reentryflag=0;
    block_TestBlock=(scicos_block*) *block->work;

    /* set blk struc. of 'capteur1' (type 0 - blk nb 1 - uid ) */
    block_TestBlock[0].type   = 0;
    block_TestBlock[0].ztyp   = 0;
    block_TestBlock[0].ng     = 0;
    block_TestBlock[0].nx     = 0;
    block_TestBlock[0].x      = &(zero);
    block_TestBlock[0].xd     = w;
    block_TestBlock[0].g      = &(zero);
    block_TestBlock[0].nz     = 0;
    block_TestBlock[0].noz    = 0;
    block_TestBlock[0].nrpar  = 0;
    block_TestBlock[0].nopar  = 0;
    block_TestBlock[0].nipar  = 1;
    block_TestBlock[0].nin    = 0;
    block_TestBlock[0].nout   = 1;
    block_TestBlock[0].nevout = 0;
    block_TestBlock[0].nmode  = 0;
    if ((block_TestBlock[0].evout  = calloc(block_TestBlock[0].nevout,sizeof(double)))== NULL) return 0;
    if ((block_TestBlock[0].insz   = malloc(3*sizeof(int)*block_TestBlock[0].nin))== NULL) return 0;
    if ((block_TestBlock[0].inptr  = malloc(sizeof(void *)*block_TestBlock[0].nin))== NULL) return 0;
    if ((block_TestBlock[0].outsz  = malloc(3*sizeof(int)*block_TestBlock[0].nout))== NULL) return 0;
    if ((block_TestBlock[0].outptr = malloc(sizeof(void*)*block_TestBlock[0].nout))== NULL) return 0;
    block_TestBlock[0].outptr[0] = TestBlock_block_outtbptr[7];
    block_TestBlock[0].outsz[0]  = 1;
    block_TestBlock[0].outsz[1]  = 1;
    block_TestBlock[0].outsz[2]  = SCSREAL_N;
    block_TestBlock[0].z         = &(z[0]);
    block_TestBlock[0].work      = (void **)(((double *)work)+0);
    block_TestBlock[0].nevprt    = nevprt;

    /* set blk struc. of 'actionneur1' (type 0 - blk nb 2 - uid ) */
    block_TestBlock[1].type   = 0;
    block_TestBlock[1].ztyp   = 0;
    block_TestBlock[1].ng     = 0;
    block_TestBlock[1].nx     = 0;
    block_TestBlock[1].x      = &(zero);
    block_TestBlock[1].xd     = w;
    block_TestBlock[1].g      = &(zero);
    block_TestBlock[1].nz     = 0;
    block_TestBlock[1].noz    = 0;
    block_TestBlock[1].nrpar  = 0;
    block_TestBlock[1].nopar  = 0;
    block_TestBlock[1].nipar  = 1;
    block_TestBlock[1].nin    = 1;
    block_TestBlock[1].nout   = 0;
    block_TestBlock[1].nevout = 0;
    block_TestBlock[1].nmode  = 0;
    if ((block_TestBlock[1].evout  = calloc(block_TestBlock[1].nevout,sizeof(double)))== NULL) return 0;
    if ((block_TestBlock[1].insz   = malloc(3*sizeof(int)*block_TestBlock[1].nin))== NULL) return 0;
    if ((block_TestBlock[1].inptr  = malloc(sizeof(void *)*block_TestBlock[1].nin))== NULL) return 0;
    block_TestBlock[1].inptr[0]  = TestBlock_block_outtbptr[3];
    block_TestBlock[1].insz[0]   = 1;
    block_TestBlock[1].insz[1]   = 1;
    block_TestBlock[1].insz[2]   = SCSREAL_N;
    if ((block_TestBlock[1].outsz  = malloc(3*sizeof(int)*block_TestBlock[1].nout))== NULL) return 0;
    if ((block_TestBlock[1].outptr = malloc(sizeof(void*)*block_TestBlock[1].nout))== NULL) return 0;
    block_TestBlock[1].z         = &(z[0]);
    block_TestBlock[1].work      = (void **)(((double *)work)+1);
    block_TestBlock[1].nevprt    = nevprt;

    /* set blk struc. of 'plusblk' (type 2 - blk nb 3 - uid ) */
    block_TestBlock[2].type   = 2;
    block_TestBlock[2].ztyp   = 0;
    block_TestBlock[2].ng     = 0;
    block_TestBlock[2].nx     = 0;
    block_TestBlock[2].x      = &(zero);
    block_TestBlock[2].xd     = w;
    block_TestBlock[2].g      = &(zero);
    block_TestBlock[2].nz     = 0;
    block_TestBlock[2].noz    = 0;
    block_TestBlock[2].nrpar  = 0;
    block_TestBlock[2].nopar  = 0;
    block_TestBlock[2].nipar  = 0;
    block_TestBlock[2].nin    = 2;
    block_TestBlock[2].nout   = 1;
    block_TestBlock[2].nevout = 0;
    block_TestBlock[2].nmode  = 0;
    if ((block_TestBlock[2].evout  = calloc(block_TestBlock[2].nevout,sizeof(double)))== NULL) return 0;
    if ((block_TestBlock[2].insz   = malloc(3*sizeof(int)*block_TestBlock[2].nin))== NULL) return 0;
    if ((block_TestBlock[2].inptr  = malloc(sizeof(void *)*block_TestBlock[2].nin))== NULL) return 0;
    block_TestBlock[2].inptr[0]  = TestBlock_block_outtbptr[7];
    block_TestBlock[2].inptr[1]  = TestBlock_block_outtbptr[8];
    block_TestBlock[2].insz[0]   = 1;
    block_TestBlock[2].insz[1]   = 1;
    block_TestBlock[2].insz[2]   = 1;
    block_TestBlock[2].insz[3]   = 1;
    block_TestBlock[2].insz[4]   = SCSREAL_N;
    block_TestBlock[2].insz[5]   = SCSREAL_N;
    if ((block_TestBlock[2].outsz  = malloc(3*sizeof(int)*block_TestBlock[2].nout))== NULL) return 0;
    if ((block_TestBlock[2].outptr = malloc(sizeof(void*)*block_TestBlock[2].nout))== NULL) return 0;
    block_TestBlock[2].outptr[0] = TestBlock_block_outtbptr[3];
    block_TestBlock[2].outsz[0]  = 1;
    block_TestBlock[2].outsz[1]  = 1;
    block_TestBlock[2].outsz[2]  = SCSREAL_N;
    block_TestBlock[2].z         = &(z[0]);
    block_TestBlock[2].work      = (void **)(((double *)work)+2);
    block_TestBlock[2].nevprt    = nevprt;

    /* set blk struc. of 'dollar' (type 0 - blk nb 4 - uid ) */
    block_TestBlock[3].type   = 0;
    block_TestBlock[3].ztyp   = 0;
    block_TestBlock[3].ng     = 0;
    block_TestBlock[3].nx     = 0;
    block_TestBlock[3].x      = &(zero);
    block_TestBlock[3].xd     = w;
    block_TestBlock[3].g      = &(zero);
    block_TestBlock[3].nz     = 1;
    block_TestBlock[3].noz    = 0;
    block_TestBlock[3].nrpar  = 0;
    block_TestBlock[3].nopar  = 0;
    block_TestBlock[3].nipar  = 0;
    block_TestBlock[3].nin    = 1;
    block_TestBlock[3].nout   = 1;
    block_TestBlock[3].nevout = 0;
    block_TestBlock[3].nmode  = 0;
    if ((block_TestBlock[3].evout  = calloc(block_TestBlock[3].nevout,sizeof(double)))== NULL) return 0;
    if ((block_TestBlock[3].insz   = malloc(3*sizeof(int)*block_TestBlock[3].nin))== NULL) return 0;
    if ((block_TestBlock[3].inptr  = malloc(sizeof(void *)*block_TestBlock[3].nin))== NULL) return 0;
    block_TestBlock[3].inptr[0]  = TestBlock_block_outtbptr[3];
    block_TestBlock[3].insz[0]   = 1;
    block_TestBlock[3].insz[1]   = 1;
    block_TestBlock[3].insz[2]   = SCSREAL_N;
    if ((block_TestBlock[3].outsz  = malloc(3*sizeof(int)*block_TestBlock[3].nout))== NULL) return 0;
    if ((block_TestBlock[3].outptr = malloc(sizeof(void*)*block_TestBlock[3].nout))== NULL) return 0;
    block_TestBlock[3].outptr[0] = TestBlock_block_outtbptr[8];
    block_TestBlock[3].outsz[0]  = 1;
    block_TestBlock[3].outsz[1]  = 1;
    block_TestBlock[3].outsz[2]  = SCSREAL_N;
    block_TestBlock[3].z         = &(z[0]);
    block_TestBlock[3].work      = (void **)(((double *)work)+3);
    block_TestBlock[3].nevprt    = nevprt;

    /* set blk struc. of 'actionneur2' (type 0 - blk nb 5 - uid ) */
    block_TestBlock[4].type   = 0;
    block_TestBlock[4].ztyp   = 0;
    block_TestBlock[4].ng     = 0;
    block_TestBlock[4].nx     = 0;
    block_TestBlock[4].x      = &(zero);
    block_TestBlock[4].xd     = w;
    block_TestBlock[4].g      = &(zero);
    block_TestBlock[4].nz     = 0;
    block_TestBlock[4].noz    = 0;
    block_TestBlock[4].nrpar  = 0;
    block_TestBlock[4].nopar  = 0;
    block_TestBlock[4].nipar  = 1;
    block_TestBlock[4].nin    = 1;
    block_TestBlock[4].nout   = 0;
    block_TestBlock[4].nevout = 0;
    block_TestBlock[4].nmode  = 0;
    if ((block_TestBlock[4].evout  = calloc(block_TestBlock[4].nevout,sizeof(double)))== NULL) return 0;
    if ((block_TestBlock[4].insz   = malloc(3*sizeof(int)*block_TestBlock[4].nin))== NULL) return 0;
    if ((block_TestBlock[4].inptr  = malloc(sizeof(void *)*block_TestBlock[4].nin))== NULL) return 0;
    block_TestBlock[4].inptr[0]  = TestBlock_block_outtbptr[1];
    block_TestBlock[4].insz[0]   = 1;
    block_TestBlock[4].insz[1]   = 1;
    block_TestBlock[4].insz[2]   = SCSREAL_N;
    if ((block_TestBlock[4].outsz  = malloc(3*sizeof(int)*block_TestBlock[4].nout))== NULL) return 0;
    if ((block_TestBlock[4].outptr = malloc(sizeof(void*)*block_TestBlock[4].nout))== NULL) return 0;
    block_TestBlock[4].z         = &(z[1]);
    block_TestBlock[4].work      = (void **)(((double *)work)+4);
    block_TestBlock[4].nevprt    = nevprt;

    /* set blk struc. of 'cstblk' (type 1 - blk nb 6 - uid ) */
    block_TestBlock[5].type   = 1;
    block_TestBlock[5].ztyp   = 0;
    block_TestBlock[5].ng     = 0;
    block_TestBlock[5].nx     = 0;
    block_TestBlock[5].x      = &(zero);
    block_TestBlock[5].xd     = w;
    block_TestBlock[5].g      = &(zero);
    block_TestBlock[5].nz     = 0;
    block_TestBlock[5].noz    = 0;
    block_TestBlock[5].nrpar  = 1;
    block_TestBlock[5].nopar  = 0;
    block_TestBlock[5].nipar  = 0;
    block_TestBlock[5].nin    = 0;
    block_TestBlock[5].nout   = 1;
    block_TestBlock[5].nevout = 0;
    block_TestBlock[5].nmode  = 0;
    if ((block_TestBlock[5].evout  = calloc(block_TestBlock[5].nevout,sizeof(double)))== NULL) return 0;
    if ((block_TestBlock[5].insz   = malloc(3*sizeof(int)*block_TestBlock[5].nin))== NULL) return 0;
    if ((block_TestBlock[5].inptr  = malloc(sizeof(void *)*block_TestBlock[5].nin))== NULL) return 0;
    if ((block_TestBlock[5].outsz  = malloc(3*sizeof(int)*block_TestBlock[5].nout))== NULL) return 0;
    if ((block_TestBlock[5].outptr = malloc(sizeof(void*)*block_TestBlock[5].nout))== NULL) return 0;
    block_TestBlock[5].outptr[0] = TestBlock_block_outtbptr[2];
    block_TestBlock[5].outsz[0]  = 1;
    block_TestBlock[5].outsz[1]  = 1;
    block_TestBlock[5].outsz[2]  = SCSREAL_N;
    block_TestBlock[5].z         = &(z[1]);
    block_TestBlock[5].rpar      = &(rpar[0]);
    block_TestBlock[5].work      = (void **)(((double *)work)+5);
    block_TestBlock[5].nevprt    = nevprt;

    /* set blk struc. of 'plusblk' (type 2 - blk nb 7 - uid ) */
    block_TestBlock[6].type   = 2;
    block_TestBlock[6].ztyp   = 0;
    block_TestBlock[6].ng     = 0;
    block_TestBlock[6].nx     = 0;
    block_TestBlock[6].x      = &(zero);
    block_TestBlock[6].xd     = w;
    block_TestBlock[6].g      = &(zero);
    block_TestBlock[6].nz     = 0;
    block_TestBlock[6].noz    = 0;
    block_TestBlock[6].nrpar  = 0;
    block_TestBlock[6].nopar  = 0;
    block_TestBlock[6].nipar  = 0;
    block_TestBlock[6].nin    = 2;
    block_TestBlock[6].nout   = 1;
    block_TestBlock[6].nevout = 0;
    block_TestBlock[6].nmode  = 0;
    if ((block_TestBlock[6].evout  = calloc(block_TestBlock[6].nevout,sizeof(double)))== NULL) return 0;
    if ((block_TestBlock[6].insz   = malloc(3*sizeof(int)*block_TestBlock[6].nin))== NULL) return 0;
    if ((block_TestBlock[6].inptr  = malloc(sizeof(void *)*block_TestBlock[6].nin))== NULL) return 0;
    block_TestBlock[6].inptr[0]  = TestBlock_block_outtbptr[2];
    block_TestBlock[6].inptr[1]  = TestBlock_block_outtbptr[4];
    block_TestBlock[6].insz[0]   = 1;
    block_TestBlock[6].insz[1]   = 1;
    block_TestBlock[6].insz[2]   = 1;
    block_TestBlock[6].insz[3]   = 1;
    block_TestBlock[6].insz[4]   = SCSREAL_N;
    block_TestBlock[6].insz[5]   = SCSREAL_N;
    if ((block_TestBlock[6].outsz  = malloc(3*sizeof(int)*block_TestBlock[6].nout))== NULL) return 0;
    if ((block_TestBlock[6].outptr = malloc(sizeof(void*)*block_TestBlock[6].nout))== NULL) return 0;
    block_TestBlock[6].outptr[0] = TestBlock_block_outtbptr[5];
    block_TestBlock[6].outsz[0]  = 1;
    block_TestBlock[6].outsz[1]  = 1;
    block_TestBlock[6].outsz[2]  = SCSREAL_N;
    block_TestBlock[6].z         = &(z[1]);
    block_TestBlock[6].work      = (void **)(((double *)work)+6);
    block_TestBlock[6].nevprt    = nevprt;

    /* set blk struc. of 'plusblk' (type 2 - blk nb 8 - uid ) */
    block_TestBlock[7].type   = 2;
    block_TestBlock[7].ztyp   = 0;
    block_TestBlock[7].ng     = 0;
    block_TestBlock[7].nx     = 0;
    block_TestBlock[7].x      = &(zero);
    block_TestBlock[7].xd     = w;
    block_TestBlock[7].g      = &(zero);
    block_TestBlock[7].nz     = 0;
    block_TestBlock[7].noz    = 0;
    block_TestBlock[7].nrpar  = 0;
    block_TestBlock[7].nopar  = 0;
    block_TestBlock[7].nipar  = 0;
    block_TestBlock[7].nin    = 2;
    block_TestBlock[7].nout   = 1;
    block_TestBlock[7].nevout = 0;
    block_TestBlock[7].nmode  = 0;
    if ((block_TestBlock[7].evout  = calloc(block_TestBlock[7].nevout,sizeof(double)))== NULL) return 0;
    if ((block_TestBlock[7].insz   = malloc(3*sizeof(int)*block_TestBlock[7].nin))== NULL) return 0;
    if ((block_TestBlock[7].inptr  = malloc(sizeof(void *)*block_TestBlock[7].nin))== NULL) return 0;
    block_TestBlock[7].inptr[0]  = TestBlock_block_outtbptr[0];
    block_TestBlock[7].inptr[1]  = TestBlock_block_outtbptr[6];
    block_TestBlock[7].insz[0]   = 1;
    block_TestBlock[7].insz[1]   = 1;
    block_TestBlock[7].insz[2]   = 1;
    block_TestBlock[7].insz[3]   = 1;
    block_TestBlock[7].insz[4]   = SCSREAL_N;
    block_TestBlock[7].insz[5]   = SCSREAL_N;
    if ((block_TestBlock[7].outsz  = malloc(3*sizeof(int)*block_TestBlock[7].nout))== NULL) return 0;
    if ((block_TestBlock[7].outptr = malloc(sizeof(void*)*block_TestBlock[7].nout))== NULL) return 0;
    block_TestBlock[7].outptr[0] = TestBlock_block_outtbptr[1];
    block_TestBlock[7].outsz[0]  = 1;
    block_TestBlock[7].outsz[1]  = 1;
    block_TestBlock[7].outsz[2]  = SCSREAL_N;
    block_TestBlock[7].z         = &(z[1]);
    block_TestBlock[7].work      = (void **)(((double *)work)+7);
    block_TestBlock[7].nevprt    = nevprt;

    /* set blk struc. of 'dollar4' (type 4 - blk nb 9 - uid ) */
    block_TestBlock[8].type   = 4;
    block_TestBlock[8].ztyp   = 0;
    block_TestBlock[8].ng     = 0;
    block_TestBlock[8].nx     = 0;
    block_TestBlock[8].x      = &(zero);
    block_TestBlock[8].xd     = w;
    block_TestBlock[8].g      = &(zero);
    block_TestBlock[8].nz     = 1;
    block_TestBlock[8].noz    = 0;
    block_TestBlock[8].nrpar  = 0;
    block_TestBlock[8].nopar  = 0;
    block_TestBlock[8].nipar  = 0;
    block_TestBlock[8].nin    = 1;
    block_TestBlock[8].nout   = 1;
    block_TestBlock[8].nevout = 0;
    block_TestBlock[8].nmode  = 0;
    if ((block_TestBlock[8].evout  = calloc(block_TestBlock[8].nevout,sizeof(double)))== NULL) return 0;
    if ((block_TestBlock[8].insz   = malloc(3*sizeof(int)*block_TestBlock[8].nin))== NULL) return 0;
    if ((block_TestBlock[8].inptr  = malloc(sizeof(void *)*block_TestBlock[8].nin))== NULL) return 0;
    block_TestBlock[8].inptr[0]  = TestBlock_block_outtbptr[1];
    block_TestBlock[8].insz[0]   = 1;
    block_TestBlock[8].insz[1]   = 1;
    block_TestBlock[8].insz[2]   = SCSREAL_N;
    if ((block_TestBlock[8].outsz  = malloc(3*sizeof(int)*block_TestBlock[8].nout))== NULL) return 0;
    if ((block_TestBlock[8].outptr = malloc(sizeof(void*)*block_TestBlock[8].nout))== NULL) return 0;
    block_TestBlock[8].outptr[0] = TestBlock_block_outtbptr[0];
    block_TestBlock[8].outsz[0]  = 1;
    block_TestBlock[8].outsz[1]  = 1;
    block_TestBlock[8].outsz[2]  = SCSREAL_N;
    block_TestBlock[8].z         = &(z[1]);
    block_TestBlock[8].work      = (void **)(((double *)work)+8);
    block_TestBlock[8].nevprt    = nevprt;

    /* set blk struc. of 'gain' (type 0 - blk nb 10 - uid ) */
    block_TestBlock[9].type   = 0;
    block_TestBlock[9].ztyp   = 0;
    block_TestBlock[9].ng     = 0;
    block_TestBlock[9].nx     = 0;
    block_TestBlock[9].x      = &(zero);
    block_TestBlock[9].xd     = w;
    block_TestBlock[9].g      = &(zero);
    block_TestBlock[9].nz     = 0;
    block_TestBlock[9].noz    = 0;
    block_TestBlock[9].nrpar  = 1;
    block_TestBlock[9].nopar  = 0;
    block_TestBlock[9].nipar  = 0;
    block_TestBlock[9].nin    = 1;
    block_TestBlock[9].nout   = 1;
    block_TestBlock[9].nevout = 0;
    block_TestBlock[9].nmode  = 0;
    if ((block_TestBlock[9].evout  = calloc(block_TestBlock[9].nevout,sizeof(double)))== NULL) return 0;
    if ((block_TestBlock[9].insz   = malloc(3*sizeof(int)*block_TestBlock[9].nin))== NULL) return 0;
    if ((block_TestBlock[9].inptr  = malloc(sizeof(void *)*block_TestBlock[9].nin))== NULL) return 0;
    block_TestBlock[9].inptr[0]  = TestBlock_block_outtbptr[0];
    block_TestBlock[9].insz[0]   = 1;
    block_TestBlock[9].insz[1]   = 1;
    block_TestBlock[9].insz[2]   = SCSREAL_N;
    if ((block_TestBlock[9].outsz  = malloc(3*sizeof(int)*block_TestBlock[9].nout))== NULL) return 0;
    if ((block_TestBlock[9].outptr = malloc(sizeof(void*)*block_TestBlock[9].nout))== NULL) return 0;
    block_TestBlock[9].outptr[0] = TestBlock_block_outtbptr[4];
    block_TestBlock[9].outsz[0]  = 1;
    block_TestBlock[9].outsz[1]  = 1;
    block_TestBlock[9].outsz[2]  = SCSREAL_N;
    block_TestBlock[9].z         = &(z[2]);
    block_TestBlock[9].rpar      = &(rpar[1]);
    block_TestBlock[9].work      = (void **)(((double *)work)+9);
    block_TestBlock[9].nevprt    = nevprt;

    /* set blk struc. of 'gain' (type 0 - blk nb 11 - uid ) */
    block_TestBlock[10].type   = 0;
    block_TestBlock[10].ztyp   = 0;
    block_TestBlock[10].ng     = 0;
    block_TestBlock[10].nx     = 0;
    block_TestBlock[10].x      = &(zero);
    block_TestBlock[10].xd     = w;
    block_TestBlock[10].g      = &(zero);
    block_TestBlock[10].nz     = 0;
    block_TestBlock[10].noz    = 0;
    block_TestBlock[10].nrpar  = 1;
    block_TestBlock[10].nopar  = 0;
    block_TestBlock[10].nipar  = 0;
    block_TestBlock[10].nin    = 1;
    block_TestBlock[10].nout   = 1;
    block_TestBlock[10].nevout = 0;
    block_TestBlock[10].nmode  = 0;
    if ((block_TestBlock[10].evout  = calloc(block_TestBlock[10].nevout,sizeof(double)))== NULL) return 0;
    if ((block_TestBlock[10].insz   = malloc(3*sizeof(int)*block_TestBlock[10].nin))== NULL) return 0;
    if ((block_TestBlock[10].inptr  = malloc(sizeof(void *)*block_TestBlock[10].nin))== NULL) return 0;
    block_TestBlock[10].inptr[0]  = TestBlock_block_outtbptr[5];
    block_TestBlock[10].insz[0]   = 1;
    block_TestBlock[10].insz[1]   = 1;
    block_TestBlock[10].insz[2]   = SCSREAL_N;
    if ((block_TestBlock[10].outsz  = malloc(3*sizeof(int)*block_TestBlock[10].nout))== NULL) return 0;
    if ((block_TestBlock[10].outptr = malloc(sizeof(void*)*block_TestBlock[10].nout))== NULL) return 0;
    block_TestBlock[10].outptr[0] = TestBlock_block_outtbptr[6];
    block_TestBlock[10].outsz[0]  = 1;
    block_TestBlock[10].outsz[1]  = 1;
    block_TestBlock[10].outsz[2]  = SCSREAL_N;
    block_TestBlock[10].z         = &(z[2]);
    block_TestBlock[10].rpar      = &(rpar[2]);
    block_TestBlock[10].work      = (void **)(((double *)work)+10);
    block_TestBlock[10].nevprt    = nevprt;

    /* set blk struc. of 'bidon' (type 1 - blk nb 12 - uid ) */
    block_TestBlock[11].type   = 1;
    block_TestBlock[11].ztyp   = 0;
    block_TestBlock[11].ng     = 0;
    block_TestBlock[11].nx     = 0;
    block_TestBlock[11].x      = &(zero);
    block_TestBlock[11].xd     = w;
    block_TestBlock[11].g      = &(zero);
    block_TestBlock[11].nz     = 0;
    block_TestBlock[11].noz    = 0;
    block_TestBlock[11].nrpar  = 0;
    block_TestBlock[11].nopar  = 0;
    block_TestBlock[11].nipar  = 0;
    block_TestBlock[11].nin    = 0;
    block_TestBlock[11].nout   = 0;
    block_TestBlock[11].nevout = 1;
    block_TestBlock[11].nmode  = 0;
    if ((block_TestBlock[11].evout  = calloc(block_TestBlock[11].nevout,sizeof(double)))== NULL) return 0;
    if ((block_TestBlock[11].insz   = malloc(3*sizeof(int)*block_TestBlock[11].nin))== NULL) return 0;
    if ((block_TestBlock[11].inptr  = malloc(sizeof(void *)*block_TestBlock[11].nin))== NULL) return 0;
    if ((block_TestBlock[11].outsz  = malloc(3*sizeof(int)*block_TestBlock[11].nout))== NULL) return 0;
    if ((block_TestBlock[11].outptr = malloc(sizeof(void*)*block_TestBlock[11].nout))== NULL) return 0;
    block_TestBlock[11].z         = &(z[2]);
    block_TestBlock[11].work      = (void **)(((double *)work)+11);
    block_TestBlock[11].nevprt    = nevprt;

    /* Call of 'capteur1' (type 0 - blk nb 1 - uid ) */
    block_TestBlock[0].nevprt = 0;
    local_flag = 4;
    nport = 1;
    TestBlock_sensor(&local_flag, &nport, &block_TestBlock[0].nevprt, \
                     &t, (SCSREAL_COP *)TestBlock_block_outtbptr[7], \
                     &nrd_1, &nrd_1, &nrd_10,aaa);
    if(local_flag < 0) return(5 - local_flag);

    /* Call of 'actionneur1' (type 0 - blk nb 2 - uid ) */
    block_TestBlock[1].nevprt = 0;
    local_flag = 4;
    nport = 1;
    TestBlock_actuator(&local_flag, &nport, &block_TestBlock[1].nevprt, \
                       &t, (SCSREAL_COP *)TestBlock_block_outtbptr[3], \
                       &nrd_1, &nrd_1, &nrd_10,bbb);
    if(local_flag < 0) return(5 - local_flag);

    /* Call of 'plusblk' (type 2 - blk nb 3 - uid ) */
    block_TestBlock[2].nevprt = 0;
    local_flag = 4;
    plusblk(&local_flag,&block_TestBlock[2].nevprt,&t,block_TestBlock[2].xd, \
             block_TestBlock[2].x,&block_TestBlock[2].nx, \
             block_TestBlock[2].z,&block_TestBlock[2].nz,block_TestBlock[2].evout, \
             &block_TestBlock[2].nevout,block_TestBlock[2].rpar,&block_TestBlock[2].nrpar, \
             block_TestBlock[2].ipar,&block_TestBlock[2].nipar, \
             (double **)block_TestBlock[2].inptr,block_TestBlock[2].insz,&block_TestBlock[2].nin, \
             (double **)block_TestBlock[2].outptr,block_TestBlock[2].outsz, &block_TestBlock[2].nout);
    if(local_flag < 0) return(5 - local_flag);

    /* Call of 'dollar' (type 0 - blk nb 4 - uid ) */
    block_TestBlock[3].nevprt = 0;
    local_flag = 4;
    args[0]=(double *)TestBlock_block_outtbptr[3];
    args[1]=(double *)TestBlock_block_outtbptr[8];
    C2F(dollar)(&local_flag,&block_TestBlock[3].nevprt,&t,block_TestBlock[3].xd, \
                block_TestBlock[3].x,&block_TestBlock[3].nx, \
                block_TestBlock[3].z,&block_TestBlock[3].nz,block_TestBlock[3].evout, \
                &block_TestBlock[3].nevout,block_TestBlock[3].rpar,&block_TestBlock[3].nrpar, \
                block_TestBlock[3].ipar,&block_TestBlock[3].nipar, \
                (double *)args[0],&nrd_1,(double *)args[1],&nrd_1);
    if(local_flag < 0) return(5 - local_flag);

    /* Call of 'actionneur2' (type 0 - blk nb 5 - uid ) */
    block_TestBlock[4].nevprt = 0;
    local_flag = 4;
    nport = 2;
    TestBlock_actuator(&local_flag, &nport, &block_TestBlock[4].nevprt, \
                       &t, (SCSREAL_COP *)TestBlock_block_outtbptr[1], \
                       &nrd_1, &nrd_1, &nrd_10,bbb);
    if(local_flag < 0) return(5 - local_flag);

    /* Call of 'cstblk' (type 1 - blk nb 6 - uid ) */
    block_TestBlock[5].nevprt = 0;
    local_flag = 4;
    C2F(cstblk)(&local_flag,&block_TestBlock[5].nevprt,&t,block_TestBlock[5].xd, \
                block_TestBlock[5].x,&block_TestBlock[5].nx, \
                block_TestBlock[5].z,&block_TestBlock[5].nz,block_TestBlock[5].evout, \
                &block_TestBlock[5].nevout,block_TestBlock[5].rpar,&block_TestBlock[5].nrpar, \
                block_TestBlock[5].ipar,&block_TestBlock[5].nipar, \
                (double *)TestBlock_block_outtbptr[2],&nrd_1);
    if(local_flag < 0) return(5 - local_flag);

    /* Call of 'plusblk' (type 2 - blk nb 7 - uid ) */
    block_TestBlock[6].nevprt = 0;
    local_flag = 4;
    plusblk(&local_flag,&block_TestBlock[6].nevprt,&t,block_TestBlock[6].xd, \
             block_TestBlock[6].x,&block_TestBlock[6].nx, \
             block_TestBlock[6].z,&block_TestBlock[6].nz,block_TestBlock[6].evout, \
             &block_TestBlock[6].nevout,block_TestBlock[6].rpar,&block_TestBlock[6].nrpar, \
             block_TestBlock[6].ipar,&block_TestBlock[6].nipar, \
             (double **)block_TestBlock[6].inptr,block_TestBlock[6].insz,&block_TestBlock[6].nin, \
             (double **)block_TestBlock[6].outptr,block_TestBlock[6].outsz, &block_TestBlock[6].nout);
    if(local_flag < 0) return(5 - local_flag);

    /* Call of 'plusblk' (type 2 - blk nb 8 - uid ) */
    block_TestBlock[7].nevprt = 0;
    local_flag = 4;
    plusblk(&local_flag,&block_TestBlock[7].nevprt,&t,block_TestBlock[7].xd, \
             block_TestBlock[7].x,&block_TestBlock[7].nx, \
             block_TestBlock[7].z,&block_TestBlock[7].nz,block_TestBlock[7].evout, \
             &block_TestBlock[7].nevout,block_TestBlock[7].rpar,&block_TestBlock[7].nrpar, \
             block_TestBlock[7].ipar,&block_TestBlock[7].nipar, \
             (double **)block_TestBlock[7].inptr,block_TestBlock[7].insz,&block_TestBlock[7].nin, \
             (double **)block_TestBlock[7].outptr,block_TestBlock[7].outsz, &block_TestBlock[7].nout);
    if(local_flag < 0) return(5 - local_flag);

    /* Call of 'dollar4' (type 4 - blk nb 9 - uid ) */
    block_TestBlock[8].nevprt = 0;
    local_flag = 4;
    dollar4(&block_TestBlock[8],local_flag);
    if(local_flag < 0) return(5 - local_flag);

    /* Call of 'gain' (type 0 - blk nb 10 - uid ) */
    block_TestBlock[9].nevprt = 0;
    local_flag = 4;
    args[0]=(double *)TestBlock_block_outtbptr[0];
    args[1]=(double *)TestBlock_block_outtbptr[4];
    C2F(gain)(&local_flag,&block_TestBlock[9].nevprt,&t,block_TestBlock[9].xd, \
              block_TestBlock[9].x,&block_TestBlock[9].nx, \
              block_TestBlock[9].z,&block_TestBlock[9].nz,block_TestBlock[9].evout, \
              &block_TestBlock[9].nevout,block_TestBlock[9].rpar,&block_TestBlock[9].nrpar, \
              block_TestBlock[9].ipar,&block_TestBlock[9].nipar, \
              (double *)args[0],&nrd_1,(double *)args[1],&nrd_1);
    if(local_flag < 0) return(5 - local_flag);

    /* Call of 'gain' (type 0 - blk nb 11 - uid ) */
    block_TestBlock[10].nevprt = 0;
    local_flag = 4;
    args[0]=(double *)TestBlock_block_outtbptr[5];
    args[1]=(double *)TestBlock_block_outtbptr[6];
    C2F(gain)(&local_flag,&block_TestBlock[10].nevprt,&t,block_TestBlock[10].xd, \
              block_TestBlock[10].x,&block_TestBlock[10].nx, \
              block_TestBlock[10].z,&block_TestBlock[10].nz,block_TestBlock[10].evout, \
              &block_TestBlock[10].nevout,block_TestBlock[10].rpar,&block_TestBlock[10].nrpar, \
              block_TestBlock[10].ipar,&block_TestBlock[10].nipar, \
              (double *)args[0],&nrd_1,(double *)args[1],&nrd_1);
    if(local_flag < 0) return(5 - local_flag);

    /* initial blocks must be called with flag 1 */
    /* Call of 'cstblk' (type 1 - blk nb 6 - uid ) */
    block_TestBlock[5].nevprt = 0;
    local_flag = 1;
    C2F(cstblk)(&local_flag,&block_TestBlock[5].nevprt,&t,block_TestBlock[5].xd, \
                block_TestBlock[5].x,&block_TestBlock[5].nx, \
                block_TestBlock[5].z,&block_TestBlock[5].nz,block_TestBlock[5].evout, \
                &block_TestBlock[5].nevout,block_TestBlock[5].rpar,&block_TestBlock[5].nrpar, \
                block_TestBlock[5].ipar,&block_TestBlock[5].nipar, \
                (double *)TestBlock_block_outtbptr[2],&nrd_1);
    if(local_flag < 0) return(5 - local_flag);

    /* Call of 'dollar4' (type 4 - blk nb 9 - uid ) */
    block_TestBlock[8].nevprt = 1;
    local_flag = 1;
    dollar4(&block_TestBlock[8],local_flag);
    if(local_flag < 0) return(5 - local_flag);

    /* Call of 'gain' (type 0 - blk nb 10 - uid ) */
    block_TestBlock[9].nevprt = 1;
    local_flag = 1;
    args[0]=(double *)TestBlock_block_outtbptr[0];
    args[1]=(double *)TestBlock_block_outtbptr[4];
    C2F(gain)(&local_flag,&block_TestBlock[9].nevprt,&t,block_TestBlock[9].xd, \
              block_TestBlock[9].x,&block_TestBlock[9].nx, \
              block_TestBlock[9].z,&block_TestBlock[9].nz,block_TestBlock[9].evout, \
              &block_TestBlock[9].nevout,block_TestBlock[9].rpar,&block_TestBlock[9].nrpar, \
              block_TestBlock[9].ipar,&block_TestBlock[9].nipar, \
              (double *)args[0],&nrd_1,(double *)args[1],&nrd_1);
    if(local_flag < 0) return(5 - local_flag);

    /* Call of 'plusblk' (type 2 - blk nb 7 - uid ) */
    block_TestBlock[6].nevprt = 3;
    local_flag = 1;
    plusblk(&local_flag,&block_TestBlock[6].nevprt,&t,block_TestBlock[6].xd, \
             block_TestBlock[6].x,&block_TestBlock[6].nx, \
             block_TestBlock[6].z,&block_TestBlock[6].nz,block_TestBlock[6].evout, \
             &block_TestBlock[6].nevout,block_TestBlock[6].rpar,&block_TestBlock[6].nrpar, \
             block_TestBlock[6].ipar,&block_TestBlock[6].nipar, \
             (double **)block_TestBlock[6].inptr,block_TestBlock[6].insz,&block_TestBlock[6].nin, \
             (double **)block_TestBlock[6].outptr,block_TestBlock[6].outsz, &block_TestBlock[6].nout);
    if(local_flag < 0) return(5 - local_flag);

    /* Call of 'gain' (type 0 - blk nb 11 - uid ) */
    block_TestBlock[10].nevprt = 1;
    local_flag = 1;
    args[0]=(double *)TestBlock_block_outtbptr[5];
    args[1]=(double *)TestBlock_block_outtbptr[6];
    C2F(gain)(&local_flag,&block_TestBlock[10].nevprt,&t,block_TestBlock[10].xd, \
              block_TestBlock[10].x,&block_TestBlock[10].nx, \
              block_TestBlock[10].z,&block_TestBlock[10].nz,block_TestBlock[10].evout, \
              &block_TestBlock[10].nevout,block_TestBlock[10].rpar,&block_TestBlock[10].nrpar, \
              block_TestBlock[10].ipar,&block_TestBlock[10].nipar, \
              (double *)args[0],&nrd_1,(double *)args[1],&nrd_1);
    if(local_flag < 0) return(5 - local_flag);

    /* Call of 'plusblk' (type 2 - blk nb 8 - uid ) */
    block_TestBlock[7].nevprt = 3;
    local_flag = 1;
    plusblk(&local_flag,&block_TestBlock[7].nevprt,&t,block_TestBlock[7].xd, \
             block_TestBlock[7].x,&block_TestBlock[7].nx, \
             block_TestBlock[7].z,&block_TestBlock[7].nz,block_TestBlock[7].evout, \
             &block_TestBlock[7].nevout,block_TestBlock[7].rpar,&block_TestBlock[7].nrpar, \
             block_TestBlock[7].ipar,&block_TestBlock[7].nipar, \
             (double **)block_TestBlock[7].inptr,block_TestBlock[7].insz,&block_TestBlock[7].nin, \
             (double **)block_TestBlock[7].outptr,block_TestBlock[7].outsz, &block_TestBlock[7].nout);
    if(local_flag < 0) return(5 - local_flag);

  }
  else if (flag == 5) { /* Ending */
    block_TestBlock=*block->work;

    /* set blk struc. of 'capteur1' (type 0 - blk nb 1 - uid ) */
    block_TestBlock[0].outptr[0] = TestBlock_block_outtbptr[7];
    block_TestBlock[0].z=&(z[0]);
    block_TestBlock[0].work=(void **)(((double *)work)+0);

    /* set blk struc. of 'actionneur1' (type 0 - blk nb 2 - uid ) */
    block_TestBlock[1].inptr[0]  = TestBlock_block_outtbptr[3];
    block_TestBlock[1].z=&(z[0]);
    block_TestBlock[1].work=(void **)(((double *)work)+1);

    /* set blk struc. of 'plusblk' (type 2 - blk nb 3 - uid ) */
    block_TestBlock[2].inptr[0]  = TestBlock_block_outtbptr[7];
    block_TestBlock[2].inptr[1]  = TestBlock_block_outtbptr[8];
    block_TestBlock[2].outptr[0] = TestBlock_block_outtbptr[3];
    block_TestBlock[2].z=&(z[0]);
    block_TestBlock[2].work=(void **)(((double *)work)+2);

    /* set blk struc. of 'dollar' (type 0 - blk nb 4 - uid ) */
    block_TestBlock[3].inptr[0]  = TestBlock_block_outtbptr[3];
    block_TestBlock[3].outptr[0] = TestBlock_block_outtbptr[8];
    block_TestBlock[3].z=&(z[0]);
    block_TestBlock[3].work=(void **)(((double *)work)+3);

    /* set blk struc. of 'actionneur2' (type 0 - blk nb 5 - uid ) */
    block_TestBlock[4].inptr[0]  = TestBlock_block_outtbptr[1];
    block_TestBlock[4].z=&(z[1]);
    block_TestBlock[4].work=(void **)(((double *)work)+4);

    /* set blk struc. of 'cstblk' (type 1 - blk nb 6 - uid ) */
    block_TestBlock[5].outptr[0] = TestBlock_block_outtbptr[2];
    block_TestBlock[5].z=&(z[1]);
    block_TestBlock[5].rpar=&(rpar[0]);
    block_TestBlock[5].work=(void **)(((double *)work)+5);

    /* set blk struc. of 'plusblk' (type 2 - blk nb 7 - uid ) */
    block_TestBlock[6].inptr[0]  = TestBlock_block_outtbptr[2];
    block_TestBlock[6].inptr[1]  = TestBlock_block_outtbptr[4];
    block_TestBlock[6].outptr[0] = TestBlock_block_outtbptr[5];
    block_TestBlock[6].z=&(z[1]);
    block_TestBlock[6].work=(void **)(((double *)work)+6);

    /* set blk struc. of 'plusblk' (type 2 - blk nb 8 - uid ) */
    block_TestBlock[7].inptr[0]  = TestBlock_block_outtbptr[0];
    block_TestBlock[7].inptr[1]  = TestBlock_block_outtbptr[6];
    block_TestBlock[7].outptr[0] = TestBlock_block_outtbptr[1];
    block_TestBlock[7].z=&(z[1]);
    block_TestBlock[7].work=(void **)(((double *)work)+7);

    /* set blk struc. of 'dollar4' (type 4 - blk nb 9 - uid ) */
    block_TestBlock[8].inptr[0]  = TestBlock_block_outtbptr[1];
    block_TestBlock[8].outptr[0] = TestBlock_block_outtbptr[0];
    block_TestBlock[8].z=&(z[1]);
    block_TestBlock[8].work=(void **)(((double *)work)+8);

    /* set blk struc. of 'gain' (type 0 - blk nb 10 - uid ) */
    block_TestBlock[9].inptr[0]  = TestBlock_block_outtbptr[0];
    block_TestBlock[9].outptr[0] = TestBlock_block_outtbptr[4];
    block_TestBlock[9].z=&(z[2]);
    block_TestBlock[9].rpar=&(rpar[1]);
    block_TestBlock[9].work=(void **)(((double *)work)+9);

    /* set blk struc. of 'gain' (type 0 - blk nb 11 - uid ) */
    block_TestBlock[10].inptr[0]  = TestBlock_block_outtbptr[5];
    block_TestBlock[10].outptr[0] = TestBlock_block_outtbptr[6];
    block_TestBlock[10].z=&(z[2]);
    block_TestBlock[10].rpar=&(rpar[2]);
    block_TestBlock[10].work=(void **)(((double *)work)+10);

    /* set blk struc. of 'bidon' (type 1 - blk nb 12 - uid ) */
    block_TestBlock[11].z=&(z[2]);
    block_TestBlock[11].work=(void **)(((double *)work)+11);

    /* Call of 'capteur1' (type 0 - blk nb 1 - uid ) */
    block_TestBlock[0].nevprt = 0;
    local_flag = 5;
    nport = 1;
    TestBlock_sensor(&local_flag, &nport, &block_TestBlock[0].nevprt, \
                     &t, (SCSREAL_COP *)TestBlock_block_outtbptr[7], \
                     &nrd_1, &nrd_1, &nrd_10,aaa);
    if(local_flag < 0) return(5 - local_flag);

    /* Call of 'actionneur1' (type 0 - blk nb 2 - uid ) */
    block_TestBlock[1].nevprt = 0;
    local_flag = 5;
    nport = 1;
    TestBlock_actuator(&local_flag, &nport, &block_TestBlock[1].nevprt, \
                       &t, (SCSREAL_COP *)TestBlock_block_outtbptr[3], \
                       &nrd_1, &nrd_1, &nrd_10,bbb);
    if(local_flag < 0) return(5 - local_flag);

    /* Call of 'plusblk' (type 2 - blk nb 3 - uid ) */
    block_TestBlock[2].nevprt = 0;
    local_flag = 5;
    plusblk(&local_flag,&block_TestBlock[2].nevprt,&t,block_TestBlock[2].xd, \
             block_TestBlock[2].x,&block_TestBlock[2].nx, \
             block_TestBlock[2].z,&block_TestBlock[2].nz,block_TestBlock[2].evout, \
             &block_TestBlock[2].nevout,block_TestBlock[2].rpar,&block_TestBlock[2].nrpar, \
             block_TestBlock[2].ipar,&block_TestBlock[2].nipar, \
             (double **)block_TestBlock[2].inptr,block_TestBlock[2].insz,&block_TestBlock[2].nin, \
             (double **)block_TestBlock[2].outptr,block_TestBlock[2].outsz, &block_TestBlock[2].nout);
    if(local_flag < 0) return(5 - local_flag);

    /* Call of 'dollar' (type 0 - blk nb 4 - uid ) */
    block_TestBlock[3].nevprt = 0;
    local_flag = 5;
    args[0]=(double *)TestBlock_block_outtbptr[3];
    args[1]=(double *)TestBlock_block_outtbptr[8];
    C2F(dollar)(&local_flag,&block_TestBlock[3].nevprt,&t,block_TestBlock[3].xd, \
                block_TestBlock[3].x,&block_TestBlock[3].nx, \
                block_TestBlock[3].z,&block_TestBlock[3].nz,block_TestBlock[3].evout, \
                &block_TestBlock[3].nevout,block_TestBlock[3].rpar,&block_TestBlock[3].nrpar, \
                block_TestBlock[3].ipar,&block_TestBlock[3].nipar, \
                (double *)args[0],&nrd_1,(double *)args[1],&nrd_1);
    if(local_flag < 0) return(5 - local_flag);

    /* Call of 'actionneur2' (type 0 - blk nb 5 - uid ) */
    block_TestBlock[4].nevprt = 0;
    local_flag = 5;
    nport = 2;
    TestBlock_actuator(&local_flag, &nport, &block_TestBlock[4].nevprt, \
                       &t, (SCSREAL_COP *)TestBlock_block_outtbptr[1], \
                       &nrd_1, &nrd_1, &nrd_10,bbb);
    if(local_flag < 0) return(5 - local_flag);

    /* Call of 'cstblk' (type 1 - blk nb 6 - uid ) */
    block_TestBlock[5].nevprt = 0;
    local_flag = 5;
    C2F(cstblk)(&local_flag,&block_TestBlock[5].nevprt,&t,block_TestBlock[5].xd, \
                block_TestBlock[5].x,&block_TestBlock[5].nx, \
                block_TestBlock[5].z,&block_TestBlock[5].nz,block_TestBlock[5].evout, \
                &block_TestBlock[5].nevout,block_TestBlock[5].rpar,&block_TestBlock[5].nrpar, \
                block_TestBlock[5].ipar,&block_TestBlock[5].nipar, \
                (double *)TestBlock_block_outtbptr[2],&nrd_1);
    if(local_flag < 0) return(5 - local_flag);

    /* Call of 'plusblk' (type 2 - blk nb 7 - uid ) */
    block_TestBlock[6].nevprt = 0;
    local_flag = 5;
    plusblk(&local_flag,&block_TestBlock[6].nevprt,&t,block_TestBlock[6].xd, \
             block_TestBlock[6].x,&block_TestBlock[6].nx, \
             block_TestBlock[6].z,&block_TestBlock[6].nz,block_TestBlock[6].evout, \
             &block_TestBlock[6].nevout,block_TestBlock[6].rpar,&block_TestBlock[6].nrpar, \
             block_TestBlock[6].ipar,&block_TestBlock[6].nipar, \
             (double **)block_TestBlock[6].inptr,block_TestBlock[6].insz,&block_TestBlock[6].nin, \
             (double **)block_TestBlock[6].outptr,block_TestBlock[6].outsz, &block_TestBlock[6].nout);
    if(local_flag < 0) return(5 - local_flag);

    /* Call of 'plusblk' (type 2 - blk nb 8 - uid ) */
    block_TestBlock[7].nevprt = 0;
    local_flag = 5;
    plusblk(&local_flag,&block_TestBlock[7].nevprt,&t,block_TestBlock[7].xd, \
             block_TestBlock[7].x,&block_TestBlock[7].nx, \
             block_TestBlock[7].z,&block_TestBlock[7].nz,block_TestBlock[7].evout, \
             &block_TestBlock[7].nevout,block_TestBlock[7].rpar,&block_TestBlock[7].nrpar, \
             block_TestBlock[7].ipar,&block_TestBlock[7].nipar, \
             (double **)block_TestBlock[7].inptr,block_TestBlock[7].insz,&block_TestBlock[7].nin, \
             (double **)block_TestBlock[7].outptr,block_TestBlock[7].outsz, &block_TestBlock[7].nout);
    if(local_flag < 0) return(5 - local_flag);

    /* Call of 'dollar4' (type 4 - blk nb 9 - uid ) */
    block_TestBlock[8].nevprt = 0;
    local_flag = 5;
    dollar4(&block_TestBlock[8],local_flag);
    if(local_flag < 0) return(5 - local_flag);

    /* Call of 'gain' (type 0 - blk nb 10 - uid ) */
    block_TestBlock[9].nevprt = 0;
    local_flag = 5;
    args[0]=(double *)TestBlock_block_outtbptr[0];
    args[1]=(double *)TestBlock_block_outtbptr[4];
    C2F(gain)(&local_flag,&block_TestBlock[9].nevprt,&t,block_TestBlock[9].xd, \
              block_TestBlock[9].x,&block_TestBlock[9].nx, \
              block_TestBlock[9].z,&block_TestBlock[9].nz,block_TestBlock[9].evout, \
              &block_TestBlock[9].nevout,block_TestBlock[9].rpar,&block_TestBlock[9].nrpar, \
              block_TestBlock[9].ipar,&block_TestBlock[9].nipar, \
              (double *)args[0],&nrd_1,(double *)args[1],&nrd_1);
    if(local_flag < 0) return(5 - local_flag);

    /* Call of 'gain' (type 0 - blk nb 11 - uid ) */
    block_TestBlock[10].nevprt = 0;
    local_flag = 5;
    args[0]=(double *)TestBlock_block_outtbptr[5];
    args[1]=(double *)TestBlock_block_outtbptr[6];
    C2F(gain)(&local_flag,&block_TestBlock[10].nevprt,&t,block_TestBlock[10].xd, \
              block_TestBlock[10].x,&block_TestBlock[10].nx, \
              block_TestBlock[10].z,&block_TestBlock[10].nz,block_TestBlock[10].evout, \
              &block_TestBlock[10].nevout,block_TestBlock[10].rpar,&block_TestBlock[10].nrpar, \
              block_TestBlock[10].ipar,&block_TestBlock[10].nipar, \
              (double *)args[0],&nrd_1,(double *)args[1],&nrd_1);
    if(local_flag < 0) return(5 - local_flag);

    for (kf = 0; kf < 12; ++kf) {
      if (block_TestBlock[kf].insz!=NULL) {
        free(block_TestBlock[kf].insz);
      }else {
        break;
      }
      if (block_TestBlock[kf].outsz!=NULL){
        free(block_TestBlock[kf].outsz);
      }else {
        break;
      }
      if (block_TestBlock[kf].nopar!=0){
        if (block_TestBlock[kf].oparptr!=NULL){
          free(block_TestBlock[kf].oparptr);
        }else {
          break;
        }
        if (block_TestBlock[kf].oparsz!=NULL){
          free(block_TestBlock[kf].oparsz);
        }else {
          break;
        }
        if (block_TestBlock[kf].opartyp!=NULL){
          free(block_TestBlock[kf].opartyp);
        }else {
          break;
        }
      }
      if (block_TestBlock[kf].noz!=0){
        if (block_TestBlock[kf].ozptr!=NULL){
          free(block_TestBlock[kf].ozptr);
        }else {
          break;
        }
        if (block_TestBlock[kf].ozsz!=NULL){
          free(block_TestBlock[kf].ozsz);
        }else {
          break;
        }
        if (block_TestBlock[kf].oztyp!=NULL){
          free(block_TestBlock[kf].oztyp);
        }else {
          break;
        }
      }
      if (block_TestBlock[kf].evout!=NULL){
        free(block_TestBlock[kf].evout);
      }else {
        break;
      }
    }
    scicos_free(block_TestBlock);
  }

  memcpy(*(y+0),*(TestBlock_block_outtbptr+3),1*sizeof(double));
  memcpy(*(y+1),*(TestBlock_block_outtbptr+1),1*sizeof(double));
  return 0;

} /* TestBlock */
