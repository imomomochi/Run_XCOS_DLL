/*
**    Code prototype for standalone use
**    Generated by Code_Generation toolbox of Xcos with scilab-6.1.0
**    Date : 09-6æœˆ-2021
*/

/* To learn how to use the standalone code, type "./standalone -h" */

/* ---- Headers ---- */
#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include <string.h>
#include <memory.h>
#include "scicos_block4.h"
#include "machine.h"
#ifndef max
#define max(a,b) ((a) >= (b) ? (a) : (b))
#endif
#ifndef min
#define min(a,b) ((a) <= (b) ? (a) : (b))
#endif

/* ---- Internals functions declaration ---- */
int TestBlock_sim(double, double, double, int);

void TestBlock_sensor(int *, int *, int *, double *,void *, int *,
   int *,int *, int);

void TestBlock_actuator(int *, int *, int *, double *, void *, int *,
   int *,int *,int);

/* prototype of 'plusblk' (type 2) */
void plusblk(int *, int *, double *, double *, double *, int *, double *, \
             int *, double *, int *, double *, int *, int *, int *, \
             double **, int *, int *, double **,int *, int *);

/* prototype of 'dollar' (type 0) */
void C2F(dollar)(int *, int *, double *, double *, double *, int *, double *, \
                 int *, double *, int *, double *, int *,int *, int *, \
                 double *, int *, double *, int *);

/* prototype of 'cstblk' (type 1) */
void C2F(cstblk)(int *, int *, double *, double *, double *, int *, double *, \
                 int *, double *, int *, double *, int *,int *, int *, \
                 double *, int * );

/* Table of constant values */
static int nrd_0 = 0;
static int nrd_1 = 1;
static int nrd_2 = 2;
static int nrd_3 = 3;
static int nrd_10 = 10;
static int nrd_11 = 11;
static int nrd_81 = 81;
static int nrd_82 = 82;
static int nrd_84 = 84;
static int nrd_811 = 811;
static int nrd_812 = 812;
static int nrd_814 = 814;

/* Some general static variables */
static double zero=0;
static double w[1];
static int aaa=0, bbb=0;
void **TestBlock_block_outtbptr;
char input[50], output[50],s[1],sf[1],se[1],ss[1],**p;
static double sci_time;
static int errflg = 0;
static char *optarg = NULL ;
static int optind = 1, offset = 0 ;
scicos_block block_TestBlock[10];

/* def real parameters */
static double RPAR1[ ] = {
/* Routine name of block: cstblk
 * Gui name of block: CONST_f
 * Compiled structure index: 7
 * Exprs: 1
 * rpar=
 */
1.0000000000000000000000000E+00,

/* Routine name of block: cstblk
 * Gui name of block: CONST_f
 * Compiled structure index: 8
 * Exprs: 1
 * rpar=
 */
1.0000000000000000000000000E+00,

/* Routine name of block: cstblk
 * Gui name of block: CONST_f
 * Compiled structure index: 9
 * Exprs: 1
 * rpar=
 */
1.0000000000000000000000000E+00,

};

/* def integer parameters */
static int IPAR1[ ] = {
/* Routine name of block: capteur1
 * Gui name of block: INPUTPORTEVTS
 * Compiled structure index: 1
 * Exprs: 1
 * ipar= {1};
 */
1,

/* Routine name of block: actionneur1
 * Gui name of block: OUTPUTPORTEVTS
 * Compiled structure index: 2
 * Exprs: 1
 * ipar= {1};
 */
1,

/* Routine name of block: actionneur2
 * Gui name of block: OUTPUTPORTEVTS
 * Compiled structure index: 6
 * Exprs: 2
 * ipar= {2};
 */
2,

};


static void usage();

/* Main program */
int main(int argc, char *argv[])
{
  double tf=30;
  double dt=0.1;
  double h=0.001;
  int solver=3;
  char * progname = argv[0];
  int c;
  strcpy(input,"");
  strcpy(output,"");
  while ((c = getopt(argc , argv, "i:o:d:t:e:s:hv")) != -1)
    switch (c) {
    case 'i':
      strcpy(input,argv[optind-1]);
      break;
    case 'o':
      strcpy(output,argv[optind-1]);
      break;
    case 'd':
      strcpy(s,argv[optind-1]);
      dt=strtod(s,p);
      break;
    case 't':
      strcpy(sf,argv[optind-1]);
      tf=strtod(sf,p);
      break;
    case 'e':
      strcpy(se,argv[optind-1]);
      h=strtod(se,p);
      break;
    case 's':
      strcpy(ss,argv[optind-1]);
      solver=(int) strtod(ss,p);
      break;
    case 'h':
      usage(progname);
      printf("Options : \n");
      printf("     -h for the help  \n");
      printf("     -v for printing the Scilab Version \n");
      printf("     -i for input file name, by default is Terminal \n");
      printf("     -o for output file name, by default is Terminal \n");
      printf("     -d for the clock period, by default is 0.1 \n");
      printf("     -t for the final time, by default is 30 \n");
      printf("     -e for the solvers step size, by default is 0.001 \n");
      printf("     -s integer parameter for select the numerical solver : \n");
      printf("        1 for Euler's method \n");
      printf("        2 for Heun's method \n");
      printf("        3 (default value) for the Fourth-Order Runge-Kutta (RK4) Formula \n");
      return 0;
      break;
    case 'v':
      printf("Generated by Code_Generation toolbox of Xcos "
             "with scilab-6.1.0 version \n");
      return 0;
      break;
    case '?':
      errflg++;
      break;
    }
    if (errflg){
      usage(progname);
      return 0;
    }
 
  TestBlock_sim(tf,dt,h,solver);
  return 0;
}

static void usage(prog)
       char *prog;
{
  fprintf(stderr, "Usage: %s [-h] [-v] [-i arg] [-o arg] "
                  "[-d arg] [-t arg] [-e arg] [-s arg]\n", prog);
}

/*----------------------------------------  External simulation function */
int TestBlock_sim(tf,dt,h,solver)

   double tf,dt,h;
   int solver;
{
  double t;
  int nevprt=1;
  int local_flag;
  int nport;
  int i;
  double *args[100];

  /* Initial values */

  /* Note that z[]=[z_initial_condition;outtbptr;work]
     z_initial_condition={100};
     outtbptr={0,0,0,0,0,0,0};
     work={0,0,0,0,0,0,0,0,0,0};
  */

  double z[]={100,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0};

  /* Routine name of block: dollar
     Gui name of block: DOLLAR_f
     Compiled structure index: 4
     Exprs: 100
     z={100};
 */

  /* outtb declaration */
  double outtb_1[]={0};
  double outtb_2[]={0};
  double outtb_3[]={0};
  double outtb_4[]={0};
  double outtb_5[]={0};
  double outtb_6[]={0};
  double outtb_7[]={0};

  /* work ptr declaration */
  void **work;

  /* Get work ptr of blocks */
  work = (void **)(z+8);

  /* Get outtbptr ptr of blocks */
  TestBlock_block_outtbptr = (void **)(z+1);

  TestBlock_block_outtbptr[0] = (void *) outtb_1;
  TestBlock_block_outtbptr[1] = (void *) outtb_2;
  TestBlock_block_outtbptr[2] = (void *) outtb_3;
  TestBlock_block_outtbptr[3] = (void *) outtb_4;
  TestBlock_block_outtbptr[4] = (void *) outtb_5;
  TestBlock_block_outtbptr[5] = (void *) outtb_6;
  TestBlock_block_outtbptr[6] = (void *) outtb_7;


  /* set blk struc. of 'capteur1' (type 0 - blk nb 1 - uid ) */
  block_TestBlock[0].type   = 0;
  block_TestBlock[0].ztyp   = 0;
  block_TestBlock[0].ng     = 0;
  block_TestBlock[0].nz     = 0;
  block_TestBlock[0].noz    = 0;
  block_TestBlock[0].nrpar  = 0;
  block_TestBlock[0].nopar  = 0;
  block_TestBlock[0].nipar  = 1;
  block_TestBlock[0].nin    = 0;
  block_TestBlock[0].nout   = 1;
  block_TestBlock[0].nevout = 0;
  block_TestBlock[0].nmode  = 0;
  if ((block_TestBlock[0].evout  = calloc(block_TestBlock[0].nevout,sizeof(double)))== NULL) return 0;
  if ((block_TestBlock[0].inptr  = malloc(sizeof(double*)*block_TestBlock[0].nin))== NULL) return 0;
  if ((block_TestBlock[0].insz   = malloc(3*sizeof(int)*block_TestBlock[0].nin))== NULL) return 0;
  if ((block_TestBlock[0].outsz  = malloc(3*sizeof(int)*block_TestBlock[0].nout))== NULL) return 0;
  if ((block_TestBlock[0].outptr = malloc(sizeof(double*)*block_TestBlock[0].nout))== NULL) return 0;
  block_TestBlock[0].outptr[0] = TestBlock_block_outtbptr[1];
  block_TestBlock[0].outsz[0]  = 1;
  block_TestBlock[0].outsz[1]  = 1;
  block_TestBlock[0].outsz[2]  = SCSREAL_N;
  block_TestBlock[0].z = &(z[0]);
  block_TestBlock[0].work = (void **)(((double *)work)+0);

  /* set blk struc. of 'actionneur1' (type 0 - blk nb 2 - uid ) */
  block_TestBlock[1].type   = 0;
  block_TestBlock[1].ztyp   = 0;
  block_TestBlock[1].ng     = 0;
  block_TestBlock[1].nz     = 0;
  block_TestBlock[1].noz    = 0;
  block_TestBlock[1].nrpar  = 0;
  block_TestBlock[1].nopar  = 0;
  block_TestBlock[1].nipar  = 1;
  block_TestBlock[1].nin    = 1;
  block_TestBlock[1].nout   = 0;
  block_TestBlock[1].nevout = 0;
  block_TestBlock[1].nmode  = 0;
  if ((block_TestBlock[1].evout  = calloc(block_TestBlock[1].nevout,sizeof(double)))== NULL) return 0;
  if ((block_TestBlock[1].inptr  = malloc(sizeof(double*)*block_TestBlock[1].nin))== NULL) return 0;
  if ((block_TestBlock[1].insz   = malloc(3*sizeof(int)*block_TestBlock[1].nin))== NULL) return 0;
  block_TestBlock[1].inptr[0]  = TestBlock_block_outtbptr[0];
  block_TestBlock[1].insz[0]   = 1;
  block_TestBlock[1].insz[1]   = 1;
  block_TestBlock[1].insz[2]   = SCSREAL_N;
  if ((block_TestBlock[1].outsz  = malloc(3*sizeof(int)*block_TestBlock[1].nout))== NULL) return 0;
  if ((block_TestBlock[1].outptr = malloc(sizeof(double*)*block_TestBlock[1].nout))== NULL) return 0;
  block_TestBlock[1].z = &(z[0]);
  block_TestBlock[1].work = (void **)(((double *)work)+1);

  /* set blk struc. of 'plusblk' (type 2 - blk nb 3 - uid ) */
  block_TestBlock[2].type   = 2;
  block_TestBlock[2].ztyp   = 0;
  block_TestBlock[2].ng     = 0;
  block_TestBlock[2].nz     = 0;
  block_TestBlock[2].noz    = 0;
  block_TestBlock[2].nrpar  = 0;
  block_TestBlock[2].nopar  = 0;
  block_TestBlock[2].nipar  = 0;
  block_TestBlock[2].nin    = 2;
  block_TestBlock[2].nout   = 1;
  block_TestBlock[2].nevout = 0;
  block_TestBlock[2].nmode  = 0;
  if ((block_TestBlock[2].evout  = calloc(block_TestBlock[2].nevout,sizeof(double)))== NULL) return 0;
  if ((block_TestBlock[2].inptr  = malloc(sizeof(double*)*block_TestBlock[2].nin))== NULL) return 0;
  if ((block_TestBlock[2].insz   = malloc(3*sizeof(int)*block_TestBlock[2].nin))== NULL) return 0;
  block_TestBlock[2].inptr[0]  = TestBlock_block_outtbptr[1];
  block_TestBlock[2].inptr[1]  = TestBlock_block_outtbptr[2];
  block_TestBlock[2].insz[0]   = 1;
  block_TestBlock[2].insz[1]   = 1;
  block_TestBlock[2].insz[2]   = 1;
  block_TestBlock[2].insz[3]   = 1;
  block_TestBlock[2].insz[4]   = SCSREAL_N;
  block_TestBlock[2].insz[5]   = SCSREAL_N;
  if ((block_TestBlock[2].outsz  = malloc(3*sizeof(int)*block_TestBlock[2].nout))== NULL) return 0;
  if ((block_TestBlock[2].outptr = malloc(sizeof(double*)*block_TestBlock[2].nout))== NULL) return 0;
  block_TestBlock[2].outptr[0] = TestBlock_block_outtbptr[0];
  block_TestBlock[2].outsz[0]  = 1;
  block_TestBlock[2].outsz[1]  = 1;
  block_TestBlock[2].outsz[2]  = SCSREAL_N;
  block_TestBlock[2].z = &(z[0]);
  block_TestBlock[2].work = (void **)(((double *)work)+2);

  /* set blk struc. of 'dollar' (type 0 - blk nb 4 - uid ) */
  block_TestBlock[3].type   = 0;
  block_TestBlock[3].ztyp   = 0;
  block_TestBlock[3].ng     = 0;
  block_TestBlock[3].nz     = 1;
  block_TestBlock[3].noz    = 0;
  block_TestBlock[3].nrpar  = 0;
  block_TestBlock[3].nopar  = 0;
  block_TestBlock[3].nipar  = 0;
  block_TestBlock[3].nin    = 1;
  block_TestBlock[3].nout   = 1;
  block_TestBlock[3].nevout = 0;
  block_TestBlock[3].nmode  = 0;
  if ((block_TestBlock[3].evout  = calloc(block_TestBlock[3].nevout,sizeof(double)))== NULL) return 0;
  if ((block_TestBlock[3].inptr  = malloc(sizeof(double*)*block_TestBlock[3].nin))== NULL) return 0;
  if ((block_TestBlock[3].insz   = malloc(3*sizeof(int)*block_TestBlock[3].nin))== NULL) return 0;
  block_TestBlock[3].inptr[0]  = TestBlock_block_outtbptr[0];
  block_TestBlock[3].insz[0]   = 1;
  block_TestBlock[3].insz[1]   = 1;
  block_TestBlock[3].insz[2]   = SCSREAL_N;
  if ((block_TestBlock[3].outsz  = malloc(3*sizeof(int)*block_TestBlock[3].nout))== NULL) return 0;
  if ((block_TestBlock[3].outptr = malloc(sizeof(double*)*block_TestBlock[3].nout))== NULL) return 0;
  block_TestBlock[3].outptr[0] = TestBlock_block_outtbptr[2];
  block_TestBlock[3].outsz[0]  = 1;
  block_TestBlock[3].outsz[1]  = 1;
  block_TestBlock[3].outsz[2]  = SCSREAL_N;
  block_TestBlock[3].z = &(z[0]);
  block_TestBlock[3].work = (void **)(((double *)work)+3);

  /* set blk struc. of 'plusblk' (type 2 - blk nb 5 - uid ) */
  block_TestBlock[4].type   = 2;
  block_TestBlock[4].ztyp   = 0;
  block_TestBlock[4].ng     = 0;
  block_TestBlock[4].nz     = 0;
  block_TestBlock[4].noz    = 0;
  block_TestBlock[4].nrpar  = 0;
  block_TestBlock[4].nopar  = 0;
  block_TestBlock[4].nipar  = 0;
  block_TestBlock[4].nin    = 3;
  block_TestBlock[4].nout   = 1;
  block_TestBlock[4].nevout = 0;
  block_TestBlock[4].nmode  = 0;
  if ((block_TestBlock[4].evout  = calloc(block_TestBlock[4].nevout,sizeof(double)))== NULL) return 0;
  if ((block_TestBlock[4].inptr  = malloc(sizeof(double*)*block_TestBlock[4].nin))== NULL) return 0;
  if ((block_TestBlock[4].insz   = malloc(3*sizeof(int)*block_TestBlock[4].nin))== NULL) return 0;
  block_TestBlock[4].inptr[0]  = TestBlock_block_outtbptr[4];
  block_TestBlock[4].inptr[1]  = TestBlock_block_outtbptr[5];
  block_TestBlock[4].inptr[2]  = TestBlock_block_outtbptr[6];
  block_TestBlock[4].insz[0]   = 1;
  block_TestBlock[4].insz[1]   = 1;
  block_TestBlock[4].insz[2]   = 1;
  block_TestBlock[4].insz[3]   = 1;
  block_TestBlock[4].insz[4]   = 1;
  block_TestBlock[4].insz[5]   = 1;
  block_TestBlock[4].insz[6]   = SCSREAL_N;
  block_TestBlock[4].insz[7]   = SCSREAL_N;
  block_TestBlock[4].insz[8]   = SCSREAL_N;
  if ((block_TestBlock[4].outsz  = malloc(3*sizeof(int)*block_TestBlock[4].nout))== NULL) return 0;
  if ((block_TestBlock[4].outptr = malloc(sizeof(double*)*block_TestBlock[4].nout))== NULL) return 0;
  block_TestBlock[4].outptr[0] = TestBlock_block_outtbptr[3];
  block_TestBlock[4].outsz[0]  = 1;
  block_TestBlock[4].outsz[1]  = 1;
  block_TestBlock[4].outsz[2]  = SCSREAL_N;
  block_TestBlock[4].z = &(z[1]);
  block_TestBlock[4].work = (void **)(((double *)work)+4);

  /* set blk struc. of 'actionneur2' (type 0 - blk nb 6 - uid ) */
  block_TestBlock[5].type   = 0;
  block_TestBlock[5].ztyp   = 0;
  block_TestBlock[5].ng     = 0;
  block_TestBlock[5].nz     = 0;
  block_TestBlock[5].noz    = 0;
  block_TestBlock[5].nrpar  = 0;
  block_TestBlock[5].nopar  = 0;
  block_TestBlock[5].nipar  = 1;
  block_TestBlock[5].nin    = 1;
  block_TestBlock[5].nout   = 0;
  block_TestBlock[5].nevout = 0;
  block_TestBlock[5].nmode  = 0;
  if ((block_TestBlock[5].evout  = calloc(block_TestBlock[5].nevout,sizeof(double)))== NULL) return 0;
  if ((block_TestBlock[5].inptr  = malloc(sizeof(double*)*block_TestBlock[5].nin))== NULL) return 0;
  if ((block_TestBlock[5].insz   = malloc(3*sizeof(int)*block_TestBlock[5].nin))== NULL) return 0;
  block_TestBlock[5].inptr[0]  = TestBlock_block_outtbptr[3];
  block_TestBlock[5].insz[0]   = 1;
  block_TestBlock[5].insz[1]   = 1;
  block_TestBlock[5].insz[2]   = SCSREAL_N;
  if ((block_TestBlock[5].outsz  = malloc(3*sizeof(int)*block_TestBlock[5].nout))== NULL) return 0;
  if ((block_TestBlock[5].outptr = malloc(sizeof(double*)*block_TestBlock[5].nout))== NULL) return 0;
  block_TestBlock[5].z = &(z[1]);
  block_TestBlock[5].work = (void **)(((double *)work)+5);

  /* set blk struc. of 'cstblk' (type 1 - blk nb 7 - uid ) */
  block_TestBlock[6].type   = 1;
  block_TestBlock[6].ztyp   = 0;
  block_TestBlock[6].ng     = 0;
  block_TestBlock[6].nz     = 0;
  block_TestBlock[6].noz    = 0;
  block_TestBlock[6].nrpar  = 1;
  block_TestBlock[6].nopar  = 0;
  block_TestBlock[6].nipar  = 0;
  block_TestBlock[6].nin    = 0;
  block_TestBlock[6].nout   = 1;
  block_TestBlock[6].nevout = 0;
  block_TestBlock[6].nmode  = 0;
  if ((block_TestBlock[6].evout  = calloc(block_TestBlock[6].nevout,sizeof(double)))== NULL) return 0;
  if ((block_TestBlock[6].inptr  = malloc(sizeof(double*)*block_TestBlock[6].nin))== NULL) return 0;
  if ((block_TestBlock[6].insz   = malloc(3*sizeof(int)*block_TestBlock[6].nin))== NULL) return 0;
  if ((block_TestBlock[6].outsz  = malloc(3*sizeof(int)*block_TestBlock[6].nout))== NULL) return 0;
  if ((block_TestBlock[6].outptr = malloc(sizeof(double*)*block_TestBlock[6].nout))== NULL) return 0;
  block_TestBlock[6].outptr[0] = TestBlock_block_outtbptr[4];
  block_TestBlock[6].outsz[0]  = 1;
  block_TestBlock[6].outsz[1]  = 1;
  block_TestBlock[6].outsz[2]  = SCSREAL_N;
  block_TestBlock[6].z = &(z[1]);
  block_TestBlock[6].rpar=&(RPAR1[0]);
  block_TestBlock[6].work = (void **)(((double *)work)+6);

  /* set blk struc. of 'cstblk' (type 1 - blk nb 8 - uid ) */
  block_TestBlock[7].type   = 1;
  block_TestBlock[7].ztyp   = 0;
  block_TestBlock[7].ng     = 0;
  block_TestBlock[7].nz     = 0;
  block_TestBlock[7].noz    = 0;
  block_TestBlock[7].nrpar  = 1;
  block_TestBlock[7].nopar  = 0;
  block_TestBlock[7].nipar  = 0;
  block_TestBlock[7].nin    = 0;
  block_TestBlock[7].nout   = 1;
  block_TestBlock[7].nevout = 0;
  block_TestBlock[7].nmode  = 0;
  if ((block_TestBlock[7].evout  = calloc(block_TestBlock[7].nevout,sizeof(double)))== NULL) return 0;
  if ((block_TestBlock[7].inptr  = malloc(sizeof(double*)*block_TestBlock[7].nin))== NULL) return 0;
  if ((block_TestBlock[7].insz   = malloc(3*sizeof(int)*block_TestBlock[7].nin))== NULL) return 0;
  if ((block_TestBlock[7].outsz  = malloc(3*sizeof(int)*block_TestBlock[7].nout))== NULL) return 0;
  if ((block_TestBlock[7].outptr = malloc(sizeof(double*)*block_TestBlock[7].nout))== NULL) return 0;
  block_TestBlock[7].outptr[0] = TestBlock_block_outtbptr[5];
  block_TestBlock[7].outsz[0]  = 1;
  block_TestBlock[7].outsz[1]  = 1;
  block_TestBlock[7].outsz[2]  = SCSREAL_N;
  block_TestBlock[7].z = &(z[1]);
  block_TestBlock[7].rpar=&(RPAR1[1]);
  block_TestBlock[7].work = (void **)(((double *)work)+7);

  /* set blk struc. of 'cstblk' (type 1 - blk nb 9 - uid ) */
  block_TestBlock[8].type   = 1;
  block_TestBlock[8].ztyp   = 0;
  block_TestBlock[8].ng     = 0;
  block_TestBlock[8].nz     = 0;
  block_TestBlock[8].noz    = 0;
  block_TestBlock[8].nrpar  = 1;
  block_TestBlock[8].nopar  = 0;
  block_TestBlock[8].nipar  = 0;
  block_TestBlock[8].nin    = 0;
  block_TestBlock[8].nout   = 1;
  block_TestBlock[8].nevout = 0;
  block_TestBlock[8].nmode  = 0;
  if ((block_TestBlock[8].evout  = calloc(block_TestBlock[8].nevout,sizeof(double)))== NULL) return 0;
  if ((block_TestBlock[8].inptr  = malloc(sizeof(double*)*block_TestBlock[8].nin))== NULL) return 0;
  if ((block_TestBlock[8].insz   = malloc(3*sizeof(int)*block_TestBlock[8].nin))== NULL) return 0;
  if ((block_TestBlock[8].outsz  = malloc(3*sizeof(int)*block_TestBlock[8].nout))== NULL) return 0;
  if ((block_TestBlock[8].outptr = malloc(sizeof(double*)*block_TestBlock[8].nout))== NULL) return 0;
  block_TestBlock[8].outptr[0] = TestBlock_block_outtbptr[6];
  block_TestBlock[8].outsz[0]  = 1;
  block_TestBlock[8].outsz[1]  = 1;
  block_TestBlock[8].outsz[2]  = SCSREAL_N;
  block_TestBlock[8].z = &(z[1]);
  block_TestBlock[8].rpar=&(RPAR1[2]);
  block_TestBlock[8].work = (void **)(((double *)work)+8);

  /* set blk struc. of 'bidon' (type 1 - blk nb 10 - uid ) */
  block_TestBlock[9].type   = 1;
  block_TestBlock[9].ztyp   = 0;
  block_TestBlock[9].ng     = 0;
  block_TestBlock[9].nz     = 0;
  block_TestBlock[9].noz    = 0;
  block_TestBlock[9].nrpar  = 0;
  block_TestBlock[9].nopar  = 0;
  block_TestBlock[9].nipar  = 0;
  block_TestBlock[9].nin    = 0;
  block_TestBlock[9].nout   = 0;
  block_TestBlock[9].nevout = 1;
  block_TestBlock[9].nmode  = 0;
  if ((block_TestBlock[9].evout  = calloc(block_TestBlock[9].nevout,sizeof(double)))== NULL) return 0;
  if ((block_TestBlock[9].inptr  = malloc(sizeof(double*)*block_TestBlock[9].nin))== NULL) return 0;
  if ((block_TestBlock[9].insz   = malloc(3*sizeof(int)*block_TestBlock[9].nin))== NULL) return 0;
  if ((block_TestBlock[9].outsz  = malloc(3*sizeof(int)*block_TestBlock[9].nout))== NULL) return 0;
  if ((block_TestBlock[9].outptr = malloc(sizeof(double*)*block_TestBlock[9].nout))== NULL) return 0;
  block_TestBlock[9].z = &(z[1]);
  block_TestBlock[9].work = (void **)(((double *)work)+9);
  if (strlen(input) > 0)
    aaa=1;
  if (strlen(output)> 0)
    bbb=1;

  /* set initial time */
  t=0.0;

  /* Initialization */

  /* Call of 'capteur1' (type 0 - blk nb 1 - uid ) */
  block_TestBlock[0].nevprt = 0;
  local_flag = 4;
  nport = 1;
  TestBlock_sensor(&local_flag, &nport, &block_TestBlock[0].nevprt, \
                   &t, (SCSREAL_COP *)TestBlock_block_outtbptr[1], \
                   &nrd_1, &nrd_1, &nrd_10,aaa);
  if(local_flag < 0) return(5 - local_flag);

  /* Call of 'actionneur1' (type 0 - blk nb 2 - uid ) */
  block_TestBlock[1].nevprt = 0;
  local_flag = 4;
  nport = 1;
  TestBlock_actuator(&local_flag, &nport, &block_TestBlock[1].nevprt, \
                     &t, (SCSREAL_COP *)TestBlock_block_outtbptr[0], \
                     &nrd_1, &nrd_1, &nrd_10,bbb);
  if(local_flag < 0) return(5 - local_flag);

  /* Call of 'plusblk' (type 2 - blk nb 3 - uid ) */
  block_TestBlock[2].nevprt = 0;
  local_flag = 4;
  plusblk(&local_flag,&block_TestBlock[2].nevprt,&t,block_TestBlock[2].xd, \
           block_TestBlock[2].x,&block_TestBlock[2].nx, \
           block_TestBlock[2].z,&block_TestBlock[2].nz,block_TestBlock[2].evout, \
           &block_TestBlock[2].nevout,block_TestBlock[2].rpar,&block_TestBlock[2].nrpar, \
           block_TestBlock[2].ipar,&block_TestBlock[2].nipar, \
           (double **)block_TestBlock[2].inptr,block_TestBlock[2].insz,&block_TestBlock[2].nin, \
           (double **)block_TestBlock[2].outptr,block_TestBlock[2].outsz, &block_TestBlock[2].nout);
  if(local_flag < 0) return(5 - local_flag);

  /* Call of 'dollar' (type 0 - blk nb 4 - uid ) */
  block_TestBlock[3].nevprt = 0;
  local_flag = 4;
  args[0]=(double *)TestBlock_block_outtbptr[0];
  args[1]=(double *)TestBlock_block_outtbptr[2];
  C2F(dollar)(&local_flag,&block_TestBlock[3].nevprt,&t,block_TestBlock[3].xd, \
              block_TestBlock[3].x,&block_TestBlock[3].nx, \
              block_TestBlock[3].z,&block_TestBlock[3].nz,block_TestBlock[3].evout, \
              &block_TestBlock[3].nevout,block_TestBlock[3].rpar,&block_TestBlock[3].nrpar, \
              block_TestBlock[3].ipar,&block_TestBlock[3].nipar, \
              (double *)args[0],&nrd_1,(double *)args[1],&nrd_1);
  if(local_flag < 0) return(5 - local_flag);

  /* Call of 'plusblk' (type 2 - blk nb 5 - uid ) */
  block_TestBlock[4].nevprt = 0;
  local_flag = 4;
  plusblk(&local_flag,&block_TestBlock[4].nevprt,&t,block_TestBlock[4].xd, \
           block_TestBlock[4].x,&block_TestBlock[4].nx, \
           block_TestBlock[4].z,&block_TestBlock[4].nz,block_TestBlock[4].evout, \
           &block_TestBlock[4].nevout,block_TestBlock[4].rpar,&block_TestBlock[4].nrpar, \
           block_TestBlock[4].ipar,&block_TestBlock[4].nipar, \
           (double **)block_TestBlock[4].inptr,block_TestBlock[4].insz,&block_TestBlock[4].nin, \
           (double **)block_TestBlock[4].outptr,block_TestBlock[4].outsz, &block_TestBlock[4].nout);
  if(local_flag < 0) return(5 - local_flag);

  /* Call of 'actionneur2' (type 0 - blk nb 6 - uid ) */
  block_TestBlock[5].nevprt = 0;
  local_flag = 4;
  nport = 2;
  TestBlock_actuator(&local_flag, &nport, &block_TestBlock[5].nevprt, \
                     &t, (SCSREAL_COP *)TestBlock_block_outtbptr[3], \
                     &nrd_1, &nrd_1, &nrd_10,bbb);
  if(local_flag < 0) return(5 - local_flag);

  /* Call of 'cstblk' (type 1 - blk nb 7 - uid ) */
  block_TestBlock[6].nevprt = 0;
  local_flag = 4;
  C2F(cstblk)(&local_flag,&block_TestBlock[6].nevprt,&t,block_TestBlock[6].xd, \
              block_TestBlock[6].x,&block_TestBlock[6].nx, \
              block_TestBlock[6].z,&block_TestBlock[6].nz,block_TestBlock[6].evout, \
              &block_TestBlock[6].nevout,block_TestBlock[6].rpar,&block_TestBlock[6].nrpar, \
              block_TestBlock[6].ipar,&block_TestBlock[6].nipar, \
              (double *)TestBlock_block_outtbptr[4],&nrd_1);
  if(local_flag < 0) return(5 - local_flag);

  /* Call of 'cstblk' (type 1 - blk nb 8 - uid ) */
  block_TestBlock[7].nevprt = 0;
  local_flag = 4;
  C2F(cstblk)(&local_flag,&block_TestBlock[7].nevprt,&t,block_TestBlock[7].xd, \
              block_TestBlock[7].x,&block_TestBlock[7].nx, \
              block_TestBlock[7].z,&block_TestBlock[7].nz,block_TestBlock[7].evout, \
              &block_TestBlock[7].nevout,block_TestBlock[7].rpar,&block_TestBlock[7].nrpar, \
              block_TestBlock[7].ipar,&block_TestBlock[7].nipar, \
              (double *)TestBlock_block_outtbptr[5],&nrd_1);
  if(local_flag < 0) return(5 - local_flag);

  /* Call of 'cstblk' (type 1 - blk nb 9 - uid ) */
  block_TestBlock[8].nevprt = 0;
  local_flag = 4;
  C2F(cstblk)(&local_flag,&block_TestBlock[8].nevprt,&t,block_TestBlock[8].xd, \
              block_TestBlock[8].x,&block_TestBlock[8].nx, \
              block_TestBlock[8].z,&block_TestBlock[8].nz,block_TestBlock[8].evout, \
              &block_TestBlock[8].nevout,block_TestBlock[8].rpar,&block_TestBlock[8].nrpar, \
              block_TestBlock[8].ipar,&block_TestBlock[8].nipar, \
              (double *)TestBlock_block_outtbptr[6],&nrd_1);
  if(local_flag < 0) return(5 - local_flag);

    /* Initial blocks must be called with flag 1 */
    /* Call of 'actionneur2' (type 0 - blk nb 6 - uid ) */
    block_TestBlock[5].nevprt = 1;
    local_flag = 1;
    nport = 2;
    TestBlock_actuator(&local_flag, &nport, &block_TestBlock[5].nevprt, \
                       &t, (SCSREAL_COP *)TestBlock_block_outtbptr[3], \
                       &nrd_1, &nrd_1, &nrd_10,bbb);
    if(local_flag < 0) return(5 - local_flag);

    /* Call of 'cstblk' (type 1 - blk nb 7 - uid ) */
    block_TestBlock[6].nevprt = 0;
    local_flag = 1;
    C2F(cstblk)(&local_flag,&block_TestBlock[6].nevprt,&t,block_TestBlock[6].xd, \
                block_TestBlock[6].x,&block_TestBlock[6].nx, \
                block_TestBlock[6].z,&block_TestBlock[6].nz,block_TestBlock[6].evout, \
                &block_TestBlock[6].nevout,block_TestBlock[6].rpar,&block_TestBlock[6].nrpar, \
                block_TestBlock[6].ipar,&block_TestBlock[6].nipar, \
                (double *)TestBlock_block_outtbptr[4],&nrd_1);
    if(local_flag < 0) return(5 - local_flag);

    /* Call of 'cstblk' (type 1 - blk nb 8 - uid ) */
    block_TestBlock[7].nevprt = 0;
    local_flag = 1;
    C2F(cstblk)(&local_flag,&block_TestBlock[7].nevprt,&t,block_TestBlock[7].xd, \
                block_TestBlock[7].x,&block_TestBlock[7].nx, \
                block_TestBlock[7].z,&block_TestBlock[7].nz,block_TestBlock[7].evout, \
                &block_TestBlock[7].nevout,block_TestBlock[7].rpar,&block_TestBlock[7].nrpar, \
                block_TestBlock[7].ipar,&block_TestBlock[7].nipar, \
                (double *)TestBlock_block_outtbptr[5],&nrd_1);
    if(local_flag < 0) return(5 - local_flag);

    /* Call of 'cstblk' (type 1 - blk nb 9 - uid ) */
    block_TestBlock[8].nevprt = 0;
    local_flag = 1;
    C2F(cstblk)(&local_flag,&block_TestBlock[8].nevprt,&t,block_TestBlock[8].xd, \
                block_TestBlock[8].x,&block_TestBlock[8].nx, \
                block_TestBlock[8].z,&block_TestBlock[8].nz,block_TestBlock[8].evout, \
                &block_TestBlock[8].nevout,block_TestBlock[8].rpar,&block_TestBlock[8].nrpar, \
                block_TestBlock[8].ipar,&block_TestBlock[8].nipar, \
                (double *)TestBlock_block_outtbptr[6],&nrd_1);
    if(local_flag < 0) return(5 - local_flag);

    /* Call of 'plusblk' (type 2 - blk nb 5 - uid ) */
    block_TestBlock[4].nevprt = 7;
    local_flag = 1;
    plusblk(&local_flag,&block_TestBlock[4].nevprt,&t,block_TestBlock[4].xd, \
             block_TestBlock[4].x,&block_TestBlock[4].nx, \
             block_TestBlock[4].z,&block_TestBlock[4].nz,block_TestBlock[4].evout, \
             &block_TestBlock[4].nevout,block_TestBlock[4].rpar,&block_TestBlock[4].nrpar, \
             block_TestBlock[4].ipar,&block_TestBlock[4].nipar, \
             (double **)block_TestBlock[4].inptr,block_TestBlock[4].insz,&block_TestBlock[4].nin, \
             (double **)block_TestBlock[4].outptr,block_TestBlock[4].outsz, &block_TestBlock[4].nout);
    if(local_flag < 0) return(5 - local_flag);


  while (t < tf) {
    /* */
    sci_time=t;

    /* Output computation */
    /* Discrete activations */
    switch (nevprt) {
      case 1 : /* Blocks activated on the event number 1 */
        /* Call of 'capteur1' (type 0 - blk nb 1 - uid ) */
        block_TestBlock[0].nevprt = 1;
        local_flag = 1;
        nport = 1;
        TestBlock_sensor(&local_flag, &nport, &block_TestBlock[0].nevprt, \
                         &t, (SCSREAL_COP *)TestBlock_block_outtbptr[1], \
                         &nrd_1, &nrd_1, &nrd_10,aaa);
        if(local_flag < 0) return(5 - local_flag);
    
        /* Call of 'actionneur1' (type 0 - blk nb 2 - uid ) */
        block_TestBlock[1].nevprt = 1;
        local_flag = 1;
        nport = 1;
        TestBlock_actuator(&local_flag, &nport, &block_TestBlock[1].nevprt, \
                           &t, (SCSREAL_COP *)TestBlock_block_outtbptr[0], \
                           &nrd_1, &nrd_1, &nrd_10,bbb);
        if(local_flag < 0) return(5 - local_flag);
    
        /* Call of 'dollar' (type 0 - blk nb 4 - uid ) */
        block_TestBlock[3].nevprt = 1;
        local_flag = 1;
        args[0]=(double *)TestBlock_block_outtbptr[0];
        args[1]=(double *)TestBlock_block_outtbptr[2];
        C2F(dollar)(&local_flag,&block_TestBlock[3].nevprt,&t,block_TestBlock[3].xd, \
                    block_TestBlock[3].x,&block_TestBlock[3].nx, \
                    block_TestBlock[3].z,&block_TestBlock[3].nz,block_TestBlock[3].evout, \
                    &block_TestBlock[3].nevout,block_TestBlock[3].rpar,&block_TestBlock[3].nrpar, \
                    block_TestBlock[3].ipar,&block_TestBlock[3].nipar, \
                    (double *)args[0],&nrd_1,(double *)args[1],&nrd_1);
        if(local_flag < 0) return(5 - local_flag);
    
        /* Call of 'plusblk' (type 2 - blk nb 3 - uid ) */
        block_TestBlock[2].nevprt = 3;
        local_flag = 1;
        plusblk(&local_flag,&block_TestBlock[2].nevprt,&t,block_TestBlock[2].xd, \
                 block_TestBlock[2].x,&block_TestBlock[2].nx, \
                 block_TestBlock[2].z,&block_TestBlock[2].nz,block_TestBlock[2].evout, \
                 &block_TestBlock[2].nevout,block_TestBlock[2].rpar,&block_TestBlock[2].nrpar, \
                 block_TestBlock[2].ipar,&block_TestBlock[2].nipar, \
                 (double **)block_TestBlock[2].inptr,block_TestBlock[2].insz,&block_TestBlock[2].nin, \
                 (double **)block_TestBlock[2].outptr,block_TestBlock[2].outsz, &block_TestBlock[2].nout);
        if(local_flag < 0) return(5 - local_flag);
    
      break;

    }
    /* Discrete state computation */
    /* Discrete activations */
    switch (nevprt) {
      case 1 : /* Blocks activated on the event number 1 */
        /* Call of 'actionneur1' (type 0 - blk nb 2 - uid ) */
        block_TestBlock[1].nevprt = 1;
        local_flag = 2;
        nport = 1;
        TestBlock_actuator(&local_flag, &nport, &block_TestBlock[1].nevprt, \
                           &t, (SCSREAL_COP *)TestBlock_block_outtbptr[0], \
                           &nrd_1, &nrd_1, &nrd_10,bbb);
        if(local_flag < 0) return(5 - local_flag);
    
        /* Call of 'dollar' (type 0 - blk nb 4 - uid ) */
        block_TestBlock[3].nevprt = 1;
        local_flag = 2;
        args[0]=(double *)TestBlock_block_outtbptr[0];
        args[1]=(double *)TestBlock_block_outtbptr[2];
        C2F(dollar)(&local_flag,&block_TestBlock[3].nevprt,&t,block_TestBlock[3].xd, \
                    block_TestBlock[3].x,&block_TestBlock[3].nx, \
                    block_TestBlock[3].z,&block_TestBlock[3].nz,block_TestBlock[3].evout, \
                    &block_TestBlock[3].nevout,block_TestBlock[3].rpar,&block_TestBlock[3].nrpar, \
                    block_TestBlock[3].ipar,&block_TestBlock[3].nipar, \
                    (double *)args[0],&nrd_1,(double *)args[1],&nrd_1);
        if(local_flag < 0) return(5 - local_flag);
    
      break;

    }

    /* update current time */
    t=t+dt;
  }

 sci_time = tf;

  /* Ending */

  /* Call of 'capteur1' (type 0 - blk nb 1 - uid ) */
  block_TestBlock[0].nevprt = 0;
  local_flag = 5;
  nport = 1;
  TestBlock_sensor(&local_flag, &nport, &block_TestBlock[0].nevprt, \
                   &t, (SCSREAL_COP *)TestBlock_block_outtbptr[1], \
                   &nrd_1, &nrd_1, &nrd_10,aaa);
  if(local_flag < 0) return(5 - local_flag);

  /* Call of 'actionneur1' (type 0 - blk nb 2 - uid ) */
  block_TestBlock[1].nevprt = 0;
  local_flag = 5;
  nport = 1;
  TestBlock_actuator(&local_flag, &nport, &block_TestBlock[1].nevprt, \
                     &t, (SCSREAL_COP *)TestBlock_block_outtbptr[0], \
                     &nrd_1, &nrd_1, &nrd_10,bbb);
  if(local_flag < 0) return(5 - local_flag);

  /* Call of 'plusblk' (type 2 - blk nb 3 - uid ) */
  block_TestBlock[2].nevprt = 0;
  local_flag = 5;
  plusblk(&local_flag,&block_TestBlock[2].nevprt,&t,block_TestBlock[2].xd, \
           block_TestBlock[2].x,&block_TestBlock[2].nx, \
           block_TestBlock[2].z,&block_TestBlock[2].nz,block_TestBlock[2].evout, \
           &block_TestBlock[2].nevout,block_TestBlock[2].rpar,&block_TestBlock[2].nrpar, \
           block_TestBlock[2].ipar,&block_TestBlock[2].nipar, \
           (double **)block_TestBlock[2].inptr,block_TestBlock[2].insz,&block_TestBlock[2].nin, \
           (double **)block_TestBlock[2].outptr,block_TestBlock[2].outsz, &block_TestBlock[2].nout);
  if(local_flag < 0) return(5 - local_flag);

  /* Call of 'dollar' (type 0 - blk nb 4 - uid ) */
  block_TestBlock[3].nevprt = 0;
  local_flag = 5;
  args[0]=(double *)TestBlock_block_outtbptr[0];
  args[1]=(double *)TestBlock_block_outtbptr[2];
  C2F(dollar)(&local_flag,&block_TestBlock[3].nevprt,&t,block_TestBlock[3].xd, \
              block_TestBlock[3].x,&block_TestBlock[3].nx, \
              block_TestBlock[3].z,&block_TestBlock[3].nz,block_TestBlock[3].evout, \
              &block_TestBlock[3].nevout,block_TestBlock[3].rpar,&block_TestBlock[3].nrpar, \
              block_TestBlock[3].ipar,&block_TestBlock[3].nipar, \
              (double *)args[0],&nrd_1,(double *)args[1],&nrd_1);
  if(local_flag < 0) return(5 - local_flag);

  /* Call of 'plusblk' (type 2 - blk nb 5 - uid ) */
  block_TestBlock[4].nevprt = 0;
  local_flag = 5;
  plusblk(&local_flag,&block_TestBlock[4].nevprt,&t,block_TestBlock[4].xd, \
           block_TestBlock[4].x,&block_TestBlock[4].nx, \
           block_TestBlock[4].z,&block_TestBlock[4].nz,block_TestBlock[4].evout, \
           &block_TestBlock[4].nevout,block_TestBlock[4].rpar,&block_TestBlock[4].nrpar, \
           block_TestBlock[4].ipar,&block_TestBlock[4].nipar, \
           (double **)block_TestBlock[4].inptr,block_TestBlock[4].insz,&block_TestBlock[4].nin, \
           (double **)block_TestBlock[4].outptr,block_TestBlock[4].outsz, &block_TestBlock[4].nout);
  if(local_flag < 0) return(5 - local_flag);

  /* Call of 'actionneur2' (type 0 - blk nb 6 - uid ) */
  block_TestBlock[5].nevprt = 0;
  local_flag = 5;
  nport = 2;
  TestBlock_actuator(&local_flag, &nport, &block_TestBlock[5].nevprt, \
                     &t, (SCSREAL_COP *)TestBlock_block_outtbptr[3], \
                     &nrd_1, &nrd_1, &nrd_10,bbb);
  if(local_flag < 0) return(5 - local_flag);

  /* Call of 'cstblk' (type 1 - blk nb 7 - uid ) */
  block_TestBlock[6].nevprt = 0;
  local_flag = 5;
  C2F(cstblk)(&local_flag,&block_TestBlock[6].nevprt,&t,block_TestBlock[6].xd, \
              block_TestBlock[6].x,&block_TestBlock[6].nx, \
              block_TestBlock[6].z,&block_TestBlock[6].nz,block_TestBlock[6].evout, \
              &block_TestBlock[6].nevout,block_TestBlock[6].rpar,&block_TestBlock[6].nrpar, \
              block_TestBlock[6].ipar,&block_TestBlock[6].nipar, \
              (double *)TestBlock_block_outtbptr[4],&nrd_1);
  if(local_flag < 0) return(5 - local_flag);

  /* Call of 'cstblk' (type 1 - blk nb 8 - uid ) */
  block_TestBlock[7].nevprt = 0;
  local_flag = 5;
  C2F(cstblk)(&local_flag,&block_TestBlock[7].nevprt,&t,block_TestBlock[7].xd, \
              block_TestBlock[7].x,&block_TestBlock[7].nx, \
              block_TestBlock[7].z,&block_TestBlock[7].nz,block_TestBlock[7].evout, \
              &block_TestBlock[7].nevout,block_TestBlock[7].rpar,&block_TestBlock[7].nrpar, \
              block_TestBlock[7].ipar,&block_TestBlock[7].nipar, \
              (double *)TestBlock_block_outtbptr[5],&nrd_1);
  if(local_flag < 0) return(5 - local_flag);

  /* Call of 'cstblk' (type 1 - blk nb 9 - uid ) */
  block_TestBlock[8].nevprt = 0;
  local_flag = 5;
  C2F(cstblk)(&local_flag,&block_TestBlock[8].nevprt,&t,block_TestBlock[8].xd, \
              block_TestBlock[8].x,&block_TestBlock[8].nx, \
              block_TestBlock[8].z,&block_TestBlock[8].nz,block_TestBlock[8].evout, \
              &block_TestBlock[8].nevout,block_TestBlock[8].rpar,&block_TestBlock[8].nrpar, \
              block_TestBlock[8].ipar,&block_TestBlock[8].nipar, \
              (double *)TestBlock_block_outtbptr[6],&nrd_1);
  if(local_flag < 0) return(5 - local_flag);

  return 0;
}

/*----------------------------------------  Lapack messag function */
void C2F(xerbla)(char *SRNAME,int *INFO,long int L)
{
  printf("** On entry to %s, parameter number %d"
         "  had an illegal value\n",SRNAME,*INFO);
}

void set_block_error(int err)
{
  return;
}

int get_phase_simulation()
{
  return 1;
}

void * scicos_malloc(size_t size)
{
  return malloc(size);
}

void scicos_free(void *p)
{
  free(p);
}

double get_scicos_time()
{
  return sci_time;
}

void do_cold_restart()
{
  return;
}

void sciprint (char *fmt)
{
  return;
}

int getopt (int argc, char *argv[], char *optstring)
{
  char *group, option, *sopt;
  int len;
  option = -1;
  optarg = NULL;
  while ( optind < argc )
    { 
      group = argv[optind];
      if ( *group != '-' )
        {
         option = -1;
         optarg = group;
         optind++;
         break;
        }
      len = strlen (group);
      group = group + offset;
      if ( *group == '-' )
        {
         group++;
         offset += 2;
        }
      else
        offset++ ;
      option = *group ;
      sopt = strchr ( optstring, option ) ;
      if ( sopt != NULL )
        {
         sopt++ ;
         if ( *sopt == ':' )
           {
             optarg = group + 1;
             if ( *optarg == '\0' )
                optarg = argv[++optind];
             if ( *optarg == '-' )
                {
                 fprintf ( stderr, "\n%s: illegal option -- %c",
                           argv[0], option );
                 option = '?';
                 break;
                }
             else
                {
                 optind++;
                 offset = 0;
                 break;
                }
           }
         if ( offset >= len )
           {
             optind++;
             offset = 0;
           }
         break;
        }
      else
        {
         fprintf ( stderr, "\n%s: illegal option -- %c", argv[0], option );
         option = '?';
         break;
        }
    }
  return ( option );
}

